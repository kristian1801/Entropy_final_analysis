---
title: "Entropsy_github_2025"
author: "Kristian Larsen"
date: "2025-02-26"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
editor_options: 
  chunk_output_type: console
---

Libraries
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(tidyverse)
library(circlize)
library(RColorBrewer)
library(scales)
library(patchwork)
library(writexl)
library(dplyr)
library(stringr)
library(forcats)
library(gridExtra)
library(purrr)
library(LMMstar)
library(kableExtra)
library(tidyquant)
library(cowplot)
library(readxl)
library(tidyr)
library(gt)
library(lava)
```


# ANALYSIS FOR SINGLE METRIC OUTCOMES

This section describes the analysis we did for metrics where each subject has a 
single outcome measure per session. This include Lempel-Ziv complexity, Meta-state complexity, Modularity and Normalised spatial component analysis

## 1. Data Preparation

### 1.1 Loading Session Data

Session timepoint data contains information about study visits and their order.
```{r}
# Original dataframe with information on subject age sex time drug project session
dd <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/timepointData.csv')
dd <- dd %>% select(-X)  # Remove index column if present
dd <- dd %>% mutate(drug = if_else(drug == 'Meskalin', "Mescaline",drug))

# Load the frame-wise displacement data for motion parameters to the model
dd.FD <- read_excel("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/FD_all.xlsx")

# Rename cols to merge
dd.FD <- dd.FD %>%
  mutate(
    # Extract project (everything before first underscore)
    project_temp = str_extract(`Subject/Session`, "^[^_]+"),
    
    # Map project names
    project = case_when(
      project_temp == "5-HT" ~ "LSD",
      project_temp == "LAM" ~ "LAM",
      project_temp == "LPM" ~ "LPM",
      TRUE ~ project_temp
    ),
    
    # Extract subject (sub-XXX pattern)
    subject = str_extract(`Subject/Session`, "sub-[^-]+"),
    
    # Extract raw session (ses-XXX pattern)
    session_temp = str_extract(`Subject/Session`, "ses-[^-]+"),
    session_temp = str_replace(session_temp, "ses-", ""),
    
    # Map session names to standardized codes
    session = case_when(
      str_detect(session_temp, regex("placebo", ignore_case = TRUE)) ~ "ses_PCB",
      str_detect(session_temp, regex("lsd", ignore_case = TRUE)) ~ "ses_LSD",
      str_detect(session_temp, regex("mdma", ignore_case = TRUE)) ~ "ses_MDA",
      str_detect(session_temp, regex("psilocybin", ignore_case = TRUE)) ~ "ses_PSI",
      str_detect(session_temp, regex("amph", ignore_case = TRUE)) ~ "ses_AMP",
      str_detect(session_temp, regex("mescaline", ignore_case = TRUE)) ~ "ses_MES",
      TRUE ~ paste0("ses_", toupper(session_temp))
    ),
    
    # Map to full drug names
    drug = case_when(
      str_detect(session_temp, regex("placebo", ignore_case = TRUE)) ~ "Placebo",
      str_detect(session_temp, regex("pcb", ignore_case = TRUE)) ~ "Placebo",
      str_detect(session_temp, regex("lsd", ignore_case = TRUE)) ~ "LSD",
      str_detect(session_temp, regex("mdma", ignore_case = TRUE)) ~ "MDMA",
      str_detect(session_temp, regex("psilocybin", ignore_case = TRUE)) ~ "Psilocybin",
      str_detect(session_temp, regex("amph", ignore_case = TRUE)) ~ "d-Amphetamine",
      str_detect(session_temp, regex("mescaline", ignore_case = TRUE)) ~ "Mescaline",
      TRUE ~ session_temp
    )
  ) %>%
  # Remove temporary columns
  select(subject, session,drug,project,`Mean FD`,`Scrubbed frames > 0.2`) %>% 
  rename(mean_fd = `Mean FD`, scrubbed_frames = `Scrubbed frames > 0.2`)
```

### 1.2 Data Preparation Function

This handles common data transformation steps needed for our analysis:
```{r}
# Create a function for common data transformation steps
prepare_data <- function(timepoint_data, metric_data) {
  # Merge datasets
  merged_data <- dplyr::left_join(timepoint_data, metric_data)
  
  # Create drug category grouping variable
  merged_data <- merged_data  %>% 
    dplyr::mutate(
      group = dplyr::case_when(
        session == "ses-PCB" ~ "placebo",
        session %in% c("ses-AMP", "ses-MDA") ~ "stimulant",
        session %in% c("ses-PSI", "ses-LSD", "ses-MES") ~ "psychedelic"
      ),
      group = factor(group, levels = c("placebo", "stimulant", "psychedelic"))
    )
  
  # Create the previous_drug column to account for potential carryover effects
  merged_data <- merged_data %>%
    dplyr::arrange(subject, time) %>%  # Ensure data is ordered by subject and time
    dplyr::group_by(subject) %>%
    dplyr::mutate(
      previous_drug = sapply(seq_along(time), function(i) {
        # Get all drugs administered before current timepoint
        prev_drugs <- drug[seq_len(i-1)]
        # Count unique drugs that are not placebo
        length(unique(prev_drugs[prev_drugs != "Placebo"]))
      })
    ) %>%
    dplyr::ungroup()
  
  # Format session variable for modeling
  merged_data$session <- gsub("-", "_", merged_data$session)
  merged_data$session <- factor(merged_data$session, 
                            levels = c("ses_PCB", "ses_AMP", "ses_MDA", 
                                       "ses_PSI", "ses_LSD", "ses_MES"))
  
  # Convert time to factor for categorical treatment in models
  merged_data$time.f <- as.factor(merged_data$time)
  
  return(merged_data)
}

# Load single metric outcomes
dd.single <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/single_metric_data.csv',sep=',')

# Prepare data for analysis
dd.test <- prepare_data(dd, dd.single)

dd.test <- dd.test %>%
  mutate(across(c(LZ_entropy, metaState, modularity_norm, ngsc_global), 
                as.numeric))

dd.test <- left_join(dd.test,dd.FD)
dd.test$session <- factor(dd.test$session, 
                            levels = c("ses_PCB", "ses_AMP", "ses_MDA", 
                                       "ses_PSI", "ses_LSD", "ses_MES"))


# These are subjects with no fMRI data but they are in the project files so we can simply filter one fMRI col to remove them
dd.test <- dd.test %>% drop_na(modularity_norm) 
# filter(subject %in% c("sub-LAM07","sub-LAM27","sub-LAM29","sub-LSD18","sub-LSD24"))

```

Motion QC: This code checks motion for each of the session
```{r}
# Set drug order and colors
drug_order <- c("Placebo", "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA")
drug_colors <- c(
  "Placebo" = "#2c3e50",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500"
)

# Convert drug to factor with specified order
dd.test <- dd.test %>%
  mutate(drug = factor(drug, levels = drug_order))

# Plot 1: Mean FD by drug
p1 <- ggplot(dd.test, aes(x = drug, y = mean_fd, fill = drug)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, linewidth = 0.6) +
  geom_point(position = position_jitter(width = 0.2, seed = 123), 
             alpha = 0.5, size = 2.5, color = "black") +
  scale_fill_manual(values = drug_colors) +
  labs(
    title = "Mean Framewise Displacement by Drug",
    x = NULL,
    y = "Mean FD (mm)"
  ) +
  theme_classic(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 13, hjust = 0.5),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "none"
  )

# Plot 2: Scrubbed frames by drug
p2 <- ggplot(dd.test, aes(x = drug, y = scrubbed_frames, fill = drug)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, linewidth = 0.6) +
  geom_point(position = position_jitter(width = 0.2, seed = 123), 
             alpha = 0.5, size = 2.5, color = "black") +
  scale_fill_manual(values = drug_colors) +
  labs(
    title = "Scrubbed Frames by Drug",
    x = NULL,
    y = "Scrubbed Frames"
  ) +
  theme_classic(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 13, hjust = 0.5),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "none"
  )

# Calculate percentage of scrubbed volumes
total_volumes <- 300
threshold_percent <- 20

dd.test <- dd.test %>%
  mutate(
    scrubbed_percent = (scrubbed_frames / total_volumes) * 100,
    exclude_motion = scrubbed_percent > threshold_percent,
    drug = factor(drug, levels = drug_order)
  )

# Plot 3: Percentage of scrubbed volumes with threshold line
p3 <- ggplot(dd.test, aes(x = drug, y = scrubbed_percent, fill = drug)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, linewidth = 0.6) +
  geom_point(aes(shape = exclude_motion), 
             position = position_jitter(width = 0.2, seed = 123), 
             alpha = 0.5, size = 2.5, color = "black") +
  geom_hline(yintercept = threshold_percent, linetype = "dashed", 
             color = "red", linewidth = 0.8) +
  scale_fill_manual(values = drug_colors) +
  scale_shape_manual(values = c(16, 4), 
                     labels = c("Pass QC", "Fail QC")) +
  labs(
    title = "Percentage of Scrubbed Volumes by Drug",
    x = NULL,
    y = "Scrubbed Volumes (%)",
    shape = "Motion QC"
  ) +
  theme_classic(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 13, hjust = 0.5),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10)
  ) +
  guides(fill = "none") +  # Remove drug legend, keep shape legend
  annotate("text", x = 6, y = threshold_percent, 
           label = "20% threshold", hjust = 1.1, vjust = -0.5, 
           color = "red", size = 4, fontface = "bold")

# Summary table
motion_summary <- dd.test %>%
  group_by(drug) %>%
  summarise(
    n_total = n(),
    n_fail = sum(exclude_motion),
    percent_fail = round((n_fail / n_total) * 100, 1),
    mean_scrubbed_pct = round(mean(scrubbed_percent), 1),
    .groups = "drop"
  )

print("Motion Quality Summary by Drug:")
print(motion_summary)

# Plot 4: Stacked bar chart
p4 <- dd.test %>%
  count(drug, exclude_motion) %>%
  group_by(drug) %>%
  mutate(prop = n / sum(n) * 100) %>%
  ggplot(aes(x = drug, y = prop, fill = exclude_motion)) +
  geom_bar(stat = "identity", alpha = 0.8, linewidth = 0.3, color = "white") +
  geom_text(aes(label = paste0(round(prop, 0), "%")), 
            position = position_stack(vjust = 0.5), size = 4, fontface = "bold") +
  scale_fill_manual(values = c("FALSE" = "#27ae60", "TRUE" = "#e74c3c"),
                   labels = c("Pass (≤20%)", "Fail (>20%)")) +
  labs(
    title = "Motion QC Pass/Fail Rate by Drug",
    x = NULL,
    y = "Percentage of Subjects (%)",
    fill = "Motion QC"
  ) +
  theme_classic(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 13, hjust = 0.5),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10)
  )

# Combined visualization with black border
combined_motion_plot <- (p1 + p2) / (p3 + p4) +
  plot_annotation(
    title = "fMRI Motion Quality Control Analysis",
    theme = theme(
      plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
      plot.border = element_rect(color = "black", fill = NA, linewidth = 1)
    )
  )

# Create exclude column based on motion thresholds
dd.test <- dd.test %>%
  mutate(
    scrubbed_percent = (scrubbed_frames / 300) * 100,
    exclude = scrubbed_percent > 20 | mean_fd > 0.5,
    drug = factor(drug, levels = drug_order)
  )


# Summary of exclusions
exclusion_summary <- dd.test %>%
  group_by(drug) %>%
  summarise(
    n_total = n(),
    n_exclude = sum(exclude),
    percent_exclude = round((n_exclude / n_total) * 100, 1),
    .groups = "drop"
  )

cat("Exclusion Summary by Drug:\n")
print(exclusion_summary)

cat("\nTotal subjects to exclude:", sum(dd.test$exclude), "out of", nrow(dd.test), 
    paste0("(", round(mean(dd.test$exclude) * 100, 1), "%)"), "\n")

dd.exclude <- dd.test %>% filter(exclude)
dd.test <- dd.test %>% filter(!exclude)
```

## 2. STATISTICAL MODELING APPROACH
# -----------------------------------------------------------
# Our models aim to test specific hypotheses about how different drug classes affect brain modularity, complexity and entropy. We include several covariates to account for important factors that might influence the results.

### 2.1 Model Structure and Covariates
# -----------------------------------------------------------
# Our primary model includes the following components:

**Dependent Variable:**
- Single outcome metric per subject: This is Lempel-Ziv complexity, modularity, meta-state complexity and whole-brain normalised sptatial component entropy

**Fixed Effects (Covariates):**
- session/group: The drug condition (either individual drugs or categories)
- sex: Participant biological sex, included to account for potential sex differences in drug response
- previous_drug: Number of previous drug exposures, controls for potential carryover or order effects
- time.f: Session order as a factor, controls for potential temporal effects regardless of drug
- project: Study cohort identifier, controls for potential differences in study populations
- FD: Frame-wise displacement to control for motion

**Random Effects Structure:**
- Primary approach: ~session|subject
  This specifies random intercepts for each subject with drug-specific variance components,
  accounting for potential individual differences in response to specific drugs

### 2.2 Full Model Analysis (Individual Drug Effects)
# -----------------------------------------------------------
# We first fit a model that examines the effects of individual drug conditions: placebo as reference

```{r full-model}
# List of dependent variables
variables <- c("LZ_entropy", "metaState", "modularity_norm", "ngsc_global")

# Function to fit model for a given variable
fit_model <- function(var_name) {
  formula_str <- paste(var_name, "~ session + mean_fd + sex + previous_drug + time.f + project")
  formula_obj <- as.formula(formula_str)
  
  lmm(formula_obj, 
      data = dd.test, 
      repetition = ~session|subject)
}

# Fit all models
models <- map(variables, fit_model) %>%
  set_names(variables)
```

## 3. PLANNED CONTRASTS AND HYPOTHESIS TESTS
# -----------------------------------------------------------
### 3.1 Primary Hypothesis (H1): Stimulants vs. Psychedelics
# -----------------------------------------------------------
# Our primary hypothesis tests whether stimulants and psychedelics differ in their effects on modularity at the group level:
# Note this is changed from the preplanned analysis to better account for the unballanced number of individuals across the drug sessions
```{r}
run_anova_contrast <- function(var_name) {
  anova(models[[var_name]], 
        ci = TRUE, 
        effect = c("grouppsychedelic - groupstimulant" = "((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) - (sessionses_AMP + sessionses_MDA)/2 = 0"))
  
}

run_anova_contrast_stimulants_only <- function(var_name) {
  anova(models[[var_name]], 
        ci = TRUE, 
        effect = c("groupstimulant" = "(sessionses_AMP + sessionses_MDA)/2 = 0"))
}

run_anova_contrast_psychedelics_only <- function(var_name) {
  anova(models[[var_name]], 
        ci = TRUE, 
        effect = c("grouppsychedelic" = " ((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) = 0"))
}

# ---- Run ANOVAs for all variables ----
anova_results <- map(variables, run_anova_contrast) %>% set_names(variables)
anova_results_stimulants_only <- map(variables, run_anova_contrast_stimulants_only) %>% set_names(variables)
anova_results_psychedelics_only <- map(variables, run_anova_contrast_psychedelics_only) %>% set_names(variables)

# ---- Helper function to extract model.tables into a dataframe ----
extract_anova_table <- function(model_list) {
  map_dfr(names(model_list), function(var_name) {
    model_tab <- model.tables(model_list[[var_name]])
    data.frame(
      contrast = rownames(model_tab),
      estimate = model_tab[, "estimate"],
      lower    = model_tab[, "lower"],
      upper    = model_tab[, "upper"],
      p_value  = model_tab[, "p.value"],
      variable = var_name,
      stringsAsFactors = FALSE
    )
  }) %>%
    mutate(variable = recode(variable,
      "LZ_entropy"      = "Lempel–Ziv Complexity",
      "metaState"       = "Meta-State Complexity",
      "modularity_norm" = "Modularity",
      "ngsc_global"     = "Global NGSC"
    ))
}

# ---- Extract into tidy dataframes ----
df_all <- extract_anova_table(anova_results)
df_all_stimulants <- extract_anova_table(anova_results_stimulants_only)
df_all_psychedelics <- extract_anova_table(anova_results_psychedelics_only)

# ---- Quick check ----
head(df_all)
head(df_all_stimulants)
head(df_all_psychedelics)

# ---- Combine and tidy data ----
df_all_long <- df_all %>%
  mutate(contrast = "Psychedelics vs Stimulants")
df_all_stimulants_long <- df_all_stimulants %>%
  mutate(contrast = "Stimulants")
df_all_psychedelics_long <- df_all_psychedelics %>%
  mutate(contrast = "Psychedelics")


df_combined <- bind_rows(df_all_stimulants_long,
                         df_all_psychedelics_long,
                         df_all_long) %>%
  mutate(
    # Rename contrasts for plotting
    contrast = case_when(
      contrast == "Stimulants" ~ "Stimulants vs Placebo",
      contrast == "Psychedelics" ~ "Psychedelics vs Placebo",
      contrast == "Psychedelics vs Stimulants" ~ "Psychedelics vs Stimulants"
    )
  ) %>%
  mutate(
    contrast = factor(contrast, levels = c("Psychedelics vs Stimulants",
                                           "Psychedelics vs Placebo",
                                           "Stimulants vs Placebo")),
    variable = factor(variable,
                      levels = c("Lempel–Ziv Complexity",
                                 "Meta-State Complexity",
                                 "Modularity",
                                 "Global NGSC"))
  )
```



### 3.2 Secondary Hypothesis: Individual Drug Comparisons
# -----------------------------------------------------------
# Our secondary hypothesis examines all pairwise comparisons between individual stimulants and psychedelics:

```{r}
# ---- 1. Run pairwise comparisons with psychedelic first ----
run_pairwise_comparisons <- function(var_name) {
  anova(models[[var_name]], 
        ci = TRUE, 
        effect = c(
          "PSI_vs_AMP" = "sessionses_PSI - sessionses_AMP = 0",
          "LSD_vs_AMP" = "sessionses_LSD - sessionses_AMP = 0",
          "MES_vs_AMP" = "sessionses_MES - sessionses_AMP = 0",
          "PSI_vs_MDA" = "sessionses_PSI - sessionses_MDA = 0",
          "LSD_vs_MDA" = "sessionses_LSD - sessionses_MDA = 0",
          "MES_vs_MDA" = "sessionses_MES - sessionses_MDA = 0"
        ))
}

# Run pairwise comparisons for all variables
pairwise_results <- map(variables, run_pairwise_comparisons) %>%
  set_names(variables)

# ---- 2. Calculate percent estimates (psychedelic minus stimulant) ----
calculate_pairwise_estimates <- function(model) {
  estimate(model, f = function(p) {
      100 * c(
      PSI_vs_AMP = (p["sessionses_PSI"] - p["sessionses_AMP"]) / p["(Intercept)"],
      LSD_vs_AMP = (p["sessionses_LSD"] - p["sessionses_AMP"]) / p["(Intercept)"],
      MES_vs_AMP = (p["sessionses_MES"] - p["sessionses_AMP"]) / p["(Intercept)"],
      PSI_vs_MDA = (p["sessionses_PSI"] - p["sessionses_MDA"]) / p["(Intercept)"],
      LSD_vs_MDA = (p["sessionses_LSD"] - p["sessionses_MDA"]) / p["(Intercept)"],
      MES_vs_MDA = (p["sessionses_MES"] - p["sessionses_MDA"]) / p["(Intercept)"]
    )
  })
}

# ---- 3. Run for all models (variables) ----
pairwise_results <- map(models, calculate_pairwise_estimates)
names(pairwise_results) <- variables

# ---- 4. Convert results to tidy dataframe ----
pairwise_df <- bind_rows(lapply(names(pairwise_results), function(var) {
  r <- as.data.frame(pairwise_results[[var]])
  r$contrast <- rownames(r)
  r %>%
    mutate(
      contrast = sub("\\..*$", "", contrast),
      variable = var
    ) %>%
    select(variable, contrast, estimate, se, df, lower, upper, p.value)
}), .id = NULL) %>%
  tibble()

# ---- 5. Clean contrast and variable names ----
contrast_map <- c(
  "PSI_vs_AMP" = "Psilocybin vs d-Amphetamine",
  "LSD_vs_AMP" = "LSD vs d-Amphetamine",
  "MES_vs_AMP" = "Mescaline vs d-Amphetamine",
  "PSI_vs_MDA" = "Psilocybin vs MDMA",
  "LSD_vs_MDA" = "LSD vs MDMA",
  "MES_vs_MDA" = "Mescaline vs MDMA"
)

variable_map <- c(
  "LZ_entropy"      = "Lempel–Ziv Complexity",
  "metaState"       = "Meta-State Complexity",
  "modularity_norm" = "Modularity",
  "ngsc_global"     = "Global NGSC"
)

pairwise_df <- pairwise_df %>%
  mutate(
    contrast_clean = contrast_map[contrast],
    variable_clean = variable_map[variable]
  )

# ---- 6. Set factor order for variables ----
pairwise_df$variable_clean <- factor(pairwise_df$variable_clean, 
                                     levels = c("Lempel–Ziv Complexity", 
                                                "Meta-State Complexity", 
                                                "Modularity", 
                                                "Global NGSC"))
```


### 3.3 Model Comparison: Testing Homogeneity within Drug Categories
# -----------------------------------------------------------
# Tests whether drugs within the same category have sufficiently similar effects

```{r}
# Function to calculate estimates for any model
calculate_estimates <- function(model) {
  estimate(model, f = function(p){
    100 * c(
      LSD = p["sessionses_LSD"] / p["(Intercept)"],
      PSI = p["sessionses_PSI"] / p["(Intercept)"],
      MES = p["sessionses_MES"] / p["(Intercept)"],
      MDMA = p["sessionses_MDA"] / p["(Intercept)"],
      AMP = p["sessionses_AMP"] / p["(Intercept)"],
      LSD_VS_PSI = (p["sessionses_LSD"] - p["sessionses_PSI"]) / p["(Intercept)"],
      LSD_VS_MES = (p["sessionses_LSD"] - p["sessionses_MES"]) / p["(Intercept)"],
      MES_VS_PSI = (p["sessionses_MES"] - p["sessionses_PSI"]) / p["(Intercept)"],
      MDMA_VS_AMP = (p["sessionses_MDA"] - p["sessionses_AMP"]) / p["(Intercept)"]
    )
  })
}
# Run for all models
results <- map(models, calculate_estimates)
names(results) <- variables

# View results
results$LZ_entropy
results$metaState   

# Get only the difference estimates
vs_df <- bind_rows(lapply(names(results), function(var) {
  r <- as.data.frame(results[[var]])
  r$contrast <- rownames(r)
  r %>%
    mutate(
      contrast = sub("\\..*$", "", contrast),
      variable = var
    ) %>%
    select(variable, contrast, estimate, se, df, lower, upper, p.value)
}), .id = NULL)

# inspect
vs_df <- tibble(vs_df)

# ---- Colors ----
drug_colors <- c(
  "d-Amphetamine" = "#8b0000",
  "MDMA"          = "#b22222",
  "Psilocybin"    = "#ffd700",
  "LSD"           = "#ffff00",
  "Mescaline"     = "#ffa500"
)
contrast_color <- "#4C72B0"
highlight_fill <- alpha("grey", 0.05)



# ---- Mapping ----
contrast_map <- c(
  "LSD_VS_PSI"    = "LSD vs Psilocybin",
  "LSD_VS_MES"    = "LSD vs Mescaline",
  "MES_VS_PSI"    = "Mescaline vs Psilocybin",
  "MDMA_VS_AMP"   = "MDMA vs d-Amphetamine",
  "LSD"           = "LSD",
  "PSI"           = "Psilocybin",
  "MES"           = "Mescaline",
  "MDMA"          = "MDMA",
  "AMP"           = "d-Amphetamine"
)
variable_map <- c(
  "LZ_entropy"      = "Lempel–Ziv Complexity",
  "metaState"       = "Meta-State Complexity",
  "modularity_norm" = "Modularity",
  "ngsc_global"     = "Global NGSC"
)

# ---- Clean dataset ----
vs_df <- vs_df %>%
  mutate(
    contrast_clean = contrast_map[contrast],
    variable_clean = variable_map[variable],
    type = case_when(
      contrast_clean %in% names(drug_colors) ~ "Drug",
      TRUE ~ "Contrast"
    )
  )
```

Create combined visualisation for the forrest plot individual contrast effects
```{r}
# ---- Combine the two dataframes ----
# Standardize column names and add source information
pairwise_combined <- pairwise_df %>%
  select(variable_clean, contrast_clean, estimate, lower, upper, se, df, p.value) %>%
  mutate(
    source = "pairwise",
    type = "Between Drug Class"
  )

vs_combined <- vs_df %>%
  select(variable_clean, contrast_clean, estimate, lower, upper, se, df, p.value) %>%
  mutate(
    source = "individual", 
    type = case_when(
      contrast_clean %in% c("d-Amphetamine", "MDMA", "Psilocybin", "LSD", "Mescaline") ~ "Drug Effect",
      TRUE ~ "Within Drug Class"
    )
  )

# Combine both dataframes
combined_df <- bind_rows(pairwise_combined, vs_combined)

# ---- Create ordering for logical grouping ----
contrast_order_combined <- c(
  # Drug effects first - reordered as requested
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",
  # Within-category contrasts
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",
  # Pairwise comparisons
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine",
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"
)

combined_df$contrast_clean <- factor(combined_df$contrast_clean, levels = contrast_order_combined)

# ---- Color mapping - individual drugs keep colors, all contrasts black ----
combined_colors <- c(
  # Drug colors - keep original colors
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  # All contrasts are black
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black",
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# ---- Set factor order for variables ----
combined_df$variable_clean <- factor(combined_df$variable_clean, 
                                     levels = c("Lempel–Ziv Complexity", 
                                                "Meta-State Complexity", 
                                                "Modularity", 
                                                "Global NGSC"))

# ---- Create combined forest plot with facet_wrap ----
ggplot(combined_df, aes(x = contrast_clean, y = estimate, color = contrast_clean)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical dashed lines to separate sections
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  # After individual drugs
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  # After within-drug comparisons
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, linewidth = 0.8) +
  scale_color_manual(values = combined_colors) +
  facet_wrap(~ variable_clean, scales = "free_y") +
  theme_classic(base_size = 13) +
  theme(
    strip.text = element_text(face = "bold", size = 12),
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none"
  )
```

## 4. VISUALIZATION
# -----------------------------------------------------------
# We visualize the results using forest plots to clearly display the effects of each drug condition relative to placebo.
```{r}
# --------------------
# Setup: colors, order
# --------------------
drug_order <- c("Placebo", "Psilocybin", "LSD", "Mescaline","d-Amphetamine", "MDMA")
drug_colors <- c(
  "Placebo" = "#2c3e50",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500"
)

# Variables to plot
variables <- c("LZ_entropy",  "ngsc_global", "metaState", "modularity_norm")

# --------------------
# Transform to long format
# --------------------
dd_long <- dd.test %>%
  pivot_longer(cols = all_of(variables), 
               names_to = "measure", 
               values_to = "value")

# Compute placebo medians per measure
placebo_medians <- dd_long %>%
  filter(drug == "Placebo") %>%
  group_by(measure) %>%
  dplyr::summarise(median_val = median(value, na.rm = TRUE))

# Label mapping for facets
facet_labels <- c(
  "LZ_entropy" = "Lempel–Ziv Complexity",
  "ngsc_global" = "Global NGSC",
  "metaState" = "Meta-State Complexity",
  "modularity_norm" = "Modularity"
)

# Force the exact order using fct_relevel
dd_long <- dd_long %>%
  mutate(measure = fct_relevel(measure, 
                                "LZ_entropy", 
                                "ngsc_global", 
                                "metaState", 
                                "modularity_norm"))

# Check the levels after
print(levels(dd_long$measure))

# Label mapping for facets
facet_labels <- c(
  "LZ_entropy" = "Lempel–Ziv Complexity",
  "ngsc_global" = "Global NGSC",
  "metaState" = "Meta-State Complexity",
  "modularity_norm" = "Modularity"
)

# --------------------
# Boxplots 
# --------------------
p <- ggplot(dd_long, aes(x = factor(drug, levels = drug_order),
                         y = value, fill = drug)) +
  
  # Jittered points
  geom_jitter(aes(color = drug), width = 0.15, alpha = 0.5, size = 1.2, show.legend = FALSE) +
  
  # Boxplots
  geom_boxplot(outlier.shape = NA, width = 0.6, alpha = 0.8, color = "black", linewidth = 0.3) +
  
  # Placebo median lines per facet
  geom_hline(data = placebo_medians, 
             aes(yintercept = median_val), 
             linetype = "dashed", color = "grey40", linewidth = 0.6, inherit.aes = FALSE) +
  
  # Colors and theme
  scale_fill_manual(values = drug_colors, guide = "none") +
  scale_color_manual(values = drug_colors, guide = "none") +
  
  facet_wrap(~factor(measure, levels = c("LZ_entropy", "ngsc_global", "metaState", "modularity_norm")), 
             scales = "free_y", ncol = 2,
             labeller = as_labeller(facet_labels)) +
  
  labs(
    x = NULL,
    y = "",
    title = ""
  ) +
  
  theme_classic(base_size = 13) +
  scale_y_continuous(expand = expansion(mult = c(0.15, 0.10))) +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 20, hjust = 0.7, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title.y = element_text(size = 12, face = "bold")
  ) +
  
  # Group separators
  geom_vline(xintercept = 1.5, linetype = "solid", color = "grey40", linewidth = 0.4) +
  geom_vline(xintercept = 4.5, linetype = "solid", color = "grey40", linewidth = 0.4)

```

# Plot the joint table where each contrast is controlled with Holm-Bonferroni across all 53 contrast measures
# Note the joint tabled is loaded in as the combined datatable is handled below after the multimetric analysis where all outcomes are combined.
```{r}
combined_detailed_table <- readRDS("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/combined_detailed_table.rds")

# ---- Filter and prepare global metrics data ----
global_plot_data <- combined_detailed_table %>%
  filter(variable %in% c("LZ_entropy", "metaState", "modularity_norm", "ngsc_global")) %>%
  mutate(
    # Clean variable names
    variable_clean = case_when(
      variable == "LZ_entropy" ~ "Lempel–Ziv Complexity",
      variable == "metaState" ~ "Meta-State Complexity",
      variable == "modularity_norm" ~ "Modularity",
      variable == "ngsc_global" ~ "Global NGSC"
    ),
    # Clean contrast names
    contrast_clean = case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    ),
    # Add type classification
    type = case_when(
      contrast_clean %in% c("d-Amphetamine", "MDMA", "Psilocybin", "LSD", "Mescaline") ~ "Drug Effect",
      contrast_clean %in% c("LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    )
  )

# ---- Create ordering for logical grouping ----
contrast_order_combined <- c(
  # Drug effects first
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",
  # Within-category contrasts
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",
  # Pairwise comparisons
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine",
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"
)

global_plot_data$contrast_clean <- factor(global_plot_data$contrast_clean, levels = contrast_order_combined)

# ---- Set factor order for variables - NEW ORDER ----
global_plot_data$variable_clean <- factor(global_plot_data$variable_clean, 
                                          levels = c("Lempel–Ziv Complexity",
                                                     "Global NGSC",
                                                     "Meta-State Complexity", 
                                                     "Modularity"))

# ---- Color mapping - individual drugs keep colors, all contrasts black ----
combined_colors <- c(
  # Drug colors
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  # All contrasts are black
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black",
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# ---- Create combined forest plot with facet_wrap ----
global_metrics_plot <- ggplot(global_plot_data, aes(x = contrast_clean, y = estimate, color = contrast_clean)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical dashed lines to separate sections
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  # After individual drugs
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  # After within-drug comparisons
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, linewidth = 0.8) +
  # Add significance stars based on p_holm
  geom_text(aes(y = upper, label = sig_star), vjust = 0.3, hjust = 0.5,
             size = 5, fontface = "bold", color = "black") +
  scale_color_manual(values = combined_colors) +
  scale_y_continuous(expand = expansion(mult = c(0.15, 0.05))) +  # More space at bottom (15%), less at top (5%)
  facet_wrap(~ variable_clean, scales = "free_y") +
  labs(y = "Estimate (%)") +
  theme_classic(base_size = 13) +
  theme(
    strip.text = element_text(face = "bold", size = 12),
    axis.title.x = element_blank(),
    axis.title.y = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none"
  )

print(global_metrics_plot)

# Save
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/global_metrics_detailed.pdf",
#        plot = global_metrics_plot, width = 12, height = 8, units = "in")
```


# ANALYSIS FOR MULTI METRIC OUTCOMES

This section describes the analysis steps for metrics where each subject has 
multiple outcome measures per session. This include multi-scale sample entropy, DCC entropy and NSCE

## 1. Data Preparation

### 1.1 Loading Session Data

Session timepoint data contains information about study visits and their order.

```{r}
# Original dataframe with information on subject age sex time drug project session
dd <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/timepointData.csv')
dd <- dd %>% select(-X)  # Remove index column if present
dd <- dd %>% mutate(drug = if_else(drug == 'Meskalin', "Mescaline",drug))

# Display the structure of the timepoint data
glimpse(dd)
library(readxl)
dd.FD <- read_excel("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/FD_all.xlsx")
dd.FD <- dd.FD %>%
  mutate(
    # Extract project (everything before first underscore)
    project_temp = str_extract(`Subject/Session`, "^[^_]+"),
    
    # Map project names
    project = case_when(
      project_temp == "5-HT" ~ "LSD",
      project_temp == "LAM" ~ "LAM",
      project_temp == "LPM" ~ "LPM",
      TRUE ~ project_temp
    ),
    
    # Extract subject (sub-XXX pattern)
    subject = str_extract(`Subject/Session`, "sub-[^-]+"),
    
    # Extract raw session (ses-XXX pattern)
    session_temp = str_extract(`Subject/Session`, "ses-[^-]+"),
    session_temp = str_replace(session_temp, "ses-", ""),
    
    # Map session names to standardized codes
    session = case_when(
      str_detect(session_temp, regex("placebo", ignore_case = TRUE)) ~ "ses_PCB",
      str_detect(session_temp, regex("lsd", ignore_case = TRUE)) ~ "ses_LSD",
      str_detect(session_temp, regex("mdma", ignore_case = TRUE)) ~ "ses_MDA",
      str_detect(session_temp, regex("psilocybin", ignore_case = TRUE)) ~ "ses_PSI",
      str_detect(session_temp, regex("amph", ignore_case = TRUE)) ~ "ses_AMP",
      str_detect(session_temp, regex("mescaline", ignore_case = TRUE)) ~ "ses_MES",
      TRUE ~ paste0("ses_", toupper(session_temp))
    ),
    
    # Map to full drug names
    drug = case_when(
      str_detect(session_temp, regex("placebo", ignore_case = TRUE)) ~ "Placebo",
      str_detect(session_temp, regex("pcb", ignore_case = TRUE)) ~ "Placebo",
      str_detect(session_temp, regex("lsd", ignore_case = TRUE)) ~ "LSD",
      str_detect(session_temp, regex("mdma", ignore_case = TRUE)) ~ "MDMA",
      str_detect(session_temp, regex("psilocybin", ignore_case = TRUE)) ~ "Psilocybin",
      str_detect(session_temp, regex("amph", ignore_case = TRUE)) ~ "d-Amphetamine",
      str_detect(session_temp, regex("mescaline", ignore_case = TRUE)) ~ "Mescaline",
      TRUE ~ session_temp
    )
  ) %>%
  # Remove temporary columns
  select(subject, session,drug,project,`Mean FD`,`Scrubbed frames > 0.2`) %>% 
  rename(mean_fd = `Mean FD`, scrubbed_frames = `Scrubbed frames > 0.2`) %>% 
   mutate(
    scrubbed_percent = (scrubbed_frames / 300) * 100,
    exclude = scrubbed_percent > 20 | mean_fd > 0.5,
    drug = factor(drug, levels = drug_order)
  )
```

### Define drug order
```{r}
drug_order <- c("Placebo",  "Psilocybin", "LSD", "Mescaline","d-Amphetamine", "MDMA")
drug_colors <- c(
  "Placebo" = "#2c3e50",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500"
)

# Load in sample entropy 
dd.sample_entropy <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/sample_entropy_network_multiscale_data_3.csv', sep=',')

# Load in NSCE
dd.regional_ngse_entropy <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/network_ngse_entropy_data.csv', sep=',')

# Load in DCC entropy 
dd.DCC <- read.csv2('/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/dcc_network_connectivity_data.csv', sep=',')
  

# Prepare data for analysis
dd.entropy <- prepare_data(dd, dd.sample_entropy)
dd.ngse <- prepare_data(dd, dd.regional_ngse_entropy)
dd.dcc <- prepare_data(dd, dd.DCC)


# Join with the motions data
dd.entropy <- left_join(dd.entropy,dd.FD)
dd.entropy$session <- factor(dd.entropy$session, 
                            levels = c("ses_PCB", "ses_AMP", "ses_MDA", 
                                       "ses_PSI", "ses_LSD", "ses_MES"))


# Join with the motions data
dd.ngse <- left_join(dd.ngse,dd.FD)
dd.ngse$session <- factor(dd.ngse$session, 
                            levels = c("ses_PCB", "ses_AMP", "ses_MDA", 
                                       "ses_PSI", "ses_LSD", "ses_MES"))

# Join with the motions data
dd.dcc <- left_join(dd.dcc,dd.FD)

# Join with the motions data
dd.dcc$session <- factor(dd.dcc$session, 
                            levels = c("ses_PCB", "ses_AMP", "ses_MDA", 
                                       "ses_PSI", "ses_LSD", "ses_MES"))
```

Quick check on what data is in there
```{r}
# Define expected counts
expected_counts <- data.frame(
  project = c("LAM", "LPM", "LSD"),
  expected = c(4, 4, 2)
)

# Find subjects with incomplete data and their sessions
incomplete_subjects <- dd.entropy %>%
  count(project, subject, name = "actual_count") %>%
  left_join(expected_counts, by = "project") %>%
  filter(actual_count < expected) %>%
  select(project, subject, actual_count, expected)

# Get the actual sessions for these incomplete subjects
incomplete_with_sessions <- dd.entropy %>%
  semi_join(incomplete_subjects, by = c("project", "subject")) %>%
  group_by(project, subject) %>%
  summarise(
    actual_count = n(),
    sessions = paste(session, collapse = ", "),
    .groups = "drop"
  ) %>%
  left_join(expected_counts, by = "project") %>%
  select(project, subject, actual_count, expected, sessions)

print(incomplete_with_sessions)

#   project subject    actual_count expected sessions                 
#   <chr>   <chr>             <int>    <dbl> <chr>                    
# 1 LPM     sub-LPM009            3        4 ses_PCB, ses_PSI, ses_MES which means missing LSD sessions
# 2 LPM     sub-LPM011            3        4 ses_LSD, ses_MES, ses_PCBs, which means missing psilocybin session
# 3 LPM     sub-LPM013            3        4 ses_PCB, ses_PSI, ses_MES, which means missing LSD session
# Otherwise all participants have full data.

# Create summary table with included and excluded counts
data_summary_with_exclusions <- dd.entropy %>%
  # Recode project names
  mutate(project = case_when(
    project == "LSD" ~ "P1",
    project == "LAM" ~ "P2", 
    project == "LPM" ~ "P3",
    TRUE ~ project
  )) %>%
  # Count total and excluded scans
  group_by(project, session) %>%
  summarise(
    n_total = n(),
    n_excluded = sum(exclude, na.rm = TRUE),
    n_included = n_total - n_excluded,
    .groups = "drop"
  ) %>%
  # Create display format: "included (excluded)"
  mutate(count_display = paste0(n_included, " (", n_excluded, ")")) %>%
  select(project, session, count_display) %>%
  pivot_wider(names_from = session, values_from = count_display, values_fill = "0 (0)") %>%
  rowwise() %>%
  mutate(
    Total = {
      # Extract numbers and sum them
      cols <- c_across(-project)
      included <- sum(as.numeric(gsub(" \\(.*", "", cols)), na.rm = TRUE)
      excluded <- sum(as.numeric(gsub(".*\\(|\\)", "", cols)), na.rm = TRUE)
      paste0(included, " (", excluded, ")")
    }
  ) %>%
  ungroup() %>%
  # Add total row
  bind_rows(
    dd.entropy %>%
      mutate(project = case_when(
        project == "LSD" ~ "P1",
        project == "LAM" ~ "P2", 
        project == "LPM" ~ "P3",
        TRUE ~ project
      )) %>%
      group_by(session) %>%
      summarise(
        n_total = n(),
        n_excluded = sum(exclude, na.rm = TRUE),
        n_included = n_total - n_excluded,
        .groups = "drop"
      ) %>%
      mutate(count_display = paste0(n_included, " (", n_excluded, ")")) %>%
      select(session, count_display) %>%
      pivot_wider(names_from = session, values_from = count_display, values_fill = "0 (0)") %>%
      mutate(project = "Total") %>%
      rowwise() %>%
      mutate(
        Total = {
          cols <- c_across(-project)
          included <- sum(as.numeric(gsub(" \\(.*", "", cols)), na.rm = TRUE)
          excluded <- sum(as.numeric(gsub(".*\\(|\\)", "", cols)), na.rm = TRUE)
          paste0(included, " (", excluded, ")")
        }
      ) %>%
      select(project, everything())
  ) %>%
  rename(Project = project) %>%
  select(Project, ses_PCB, ses_AMP, ses_MDA, ses_PSI, ses_LSD, ses_MES, Total)

# Create publication-ready HTML table with clinical trial note
publication_table <- data_summary_with_exclusions %>%
  kbl(col.names = c("Project", "Placebo", "d-Amphetamine", "MDMA", "Psilocybin", "LSD", "Mescaline", "Total"),
      caption = "Number of scans by project and drug condition. Values shown as included (excluded due to motion).") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE,
                position = "center") %>%
  row_spec(nrow(data_summary_with_exclusions), bold = TRUE) %>%  # Bold the total row
  column_spec(ncol(data_summary_with_exclusions), bold = TRUE) %>%   # Bold the total column
  footnote(general = "P1: NCT02308969; P2: NCT03019822; P3: NCT04227756",
           general_title = "Clinical Trial Registration: ",
           footnote_as_chunk = TRUE)

print(publication_table)

# Motion quality summary by drug
motion_quality_table <- dd.entropy %>%
  group_by(drug) %>%
  summarise(
    N = n(),
    `N Excluded` = sum(exclude),
    `Mean FD (mm)` = round(mean(mean_fd), 3),
    `SD FD` = round(sd(mean_fd), 3),
    `Mean Scrubbed %` = round(mean(scrubbed_percent), 1),
    `SD Scrubbed %` = round(sd(scrubbed_percent), 1),
    .groups = "drop"
  )

motion_table <- motion_quality_table %>%
  kbl(caption = "Motion quality metrics by drug condition") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  footnote(general = "Exclusion criteria: >20% scrubbed volumes or mean FD >0.5mm",
           footnote_as_chunk = TRUE)


# Save as HTML
#save_kable(publication_table, "data_summary_table.html")

# Exclude the subjects with too much motion for each of the datatables
dd.ngse <- dd.ngse %>% filter(!exclude)
dd.entropy <- dd.entropy %>% filter(!exclude)
dd.dcc <- dd.dcc %>% filter(!exclude)
```
## 2. STATISTICAL MODELING APPROACH
# -----------------------------------------------------------
# Our models aim to test specific hypotheses about how different drug classes affect multiscale sample entropy across various brain networks at different scales.

### 2.1 Model Structure and Covariates
# -----------------------------------------------------------
# Our primary model includes the following components:

**Dependent Variable:**
- Multiple outcome metrics per subject: Entropy values for 7 brain networks (Cont, Default, DorsAttn, Limbic, SalVentAttn, SomMot, Vis) at two scales (1 and 5). For NSCE it is 7 network outcome measures, for DCC entropy it is 28. 53 tests in total including the four whole brain measures

**Fixed Effects (Covariates):**
- session/group: The drug condition (either individual drugs or categories)
- sex: Participant biological sex, included to account for potential sex differences in drug response
- previous_drug: Number of previous drug exposures, controls for potential carryover or order effects
- time.f: Session order as a factor, controls for potential temporal effects regardless of drug
- project: Study cohort identifier, controls for potential differences in study populations

**Random Effects Structure:**
- Primary approach: ~session|subject
  This specifies random intercepts for each subject with drug-specific variance components,
  accounting for potential individual differences in response to specific drugs

**Contingency Plan for Model Convergence:**
If the primary model fails to converge with ~session|subject random effects structure,
we will implement the following alternative approach:
1. Use time variable as the repetition factor: ~time|subject

### 2.2 Network-Specific Models
# -----------------------------------------------------------
# We will fit separate models for each brain network for all measures and networks:

```{r}
# Define networks and scales
networks <- c("Cont", "Default", "DorsAttn", "Limbic", "SalVentAttn", "SomMot", "Vis")
scales <- c(1, 5)

# Create all network-scale combinations systematically
network_scale_cols <- outer(networks, scales, FUN = function(net, scale) paste0(net, "_scale", scale))
network_scale_cols <- as.vector(network_scale_cols)
network_to_network <- paste0(networks, '_', networks)
dcc_networks <- colnames(dd.DCC)[3:38]
dcc_networks <- dcc_networks[!grepl("Subcortical", dcc_networks)]

dd.entropy <- dd.entropy %>% mutate(across(all_of(network_scale_cols), as.numeric))
dd.ngse <- dd.ngse %>% mutate(across(all_of(networks), as.numeric))
dd.dcc <- dd.dcc %>% mutate(across(all_of(dcc_networks), as.numeric))
dd.dcc <- dd.dcc %>% filter(!exclude)
dd.ngse <- dd.ngse %>% filter(!exclude)
dd.entropy <- dd.entropy %>% filter(!exclude)

# Create list of simple models 
simple_model_lst_ngse <- lapply(networks, function(i){
  f = paste0(i,"~session + sex + mean_fd + previous_drug + time.f + project")
  return(lmm(as.formula(f), data = dd.ngse, repetition = ~session|subject))
})

simple_model_lst_DCC <- lapply(dcc_networks, function(i){
  f <- paste0(i, " ~ session + sex + mean_fd + previous_drug + time.f + project")
  cat("Fitting model for:", i, "\n")
  
  try_fit <- function(rep_formula) {
    tryCatch({
      lmm(as.formula(f), data = dd.dcc, repetition = rep_formula)
    }, error = function(e) NULL)
  }
  
  # Try successively simpler models
  fit <- try_fit(~session | subject)
  if (is.null(fit)) fit <- try_fit(~time.f | subject)
  if (is.null(fit)) fit <- try_fit(~1 | subject)
  
  return(fit)  # always return the best available model object (not a list)
})

# Create list of simple models 
simple_model_lst <- lapply(network_scale_cols, function(i){
  f = paste0(i,"~session + sex + mean_fd + previous_drug + time.f + project")
  return(lmm(as.formula(f), data = dd.entropy, repetition = ~session|subject))
})
```


## 3. CONTRASTS AND HYPOTHESIS TESTS
# -----------------------------------------------------------
# Our analytical approach includes specific planned contrasts to test our primary and secondary hypotheses.

### 3.1 Primary Hypothesis (H1): Stimulants vs. Psychedelics by Network and Scale
# -----------------------------------------------------------
# Our primary hypothesis tests whether stimulants and psychedelics differ in their effects on entropy at the group level
# for each network and scale:

```{r}
# Multivariate Wald Tests For Linear Mixed Model - Simple Models
simple_ano_lst <- lapply(simple_model_lst, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic - groupstimulant" = "((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) - (sessionses_AMP + sessionses_MDA)/2 = 0")))
})

# Multivariate Wald Tests For Linear Mixed Model - Simple Models
simple_ano_lst_ngse <- lapply(simple_model_lst_ngse, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic - groupstimulant" = "((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) - (sessionses_AMP + sessionses_MDA)/2 = 0")))
})

# Multivariate Wald Tests For Linear Mixed Model - Simple Models
simple_ano_lst_dcc <- lapply(simple_model_lst_DCC, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic - groupstimulant" = "((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) - (sessionses_AMP + sessionses_MDA)/2 = 0")))
})


## combine hypotheses for the simple models
simple_list <- do.call("rbind", simple_ano_lst)
simple_list_ngse <- do.call("rbind", simple_ano_lst_ngse)
simple_list_dcc <- do.call("rbind", simple_ano_lst_dcc)
```


Now we model each individual contrasts for sample entropy
```{r}
# For stimulants vs placebo
simple_ano_lst_stimulants <- lapply(simple_model_lst, function(i){
  return(anova(i, ci = TRUE, effect = c("groupstimulant" = "(sessionses_AMP + sessionses_MDA)/2 = 0")))
})
simple_list_stimulants <- do.call("rbind", simple_ano_lst_stimulants)

# For Psychedelics vs placebo
simple_ano_lst_psychedelics <- lapply(simple_model_lst, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic" = " ((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) = 0")))
})
simple_list_psychedelics <- do.call("rbind", simple_ano_lst_psychedelics)

# ---- Function to prepare forest data ----
prepare_forest_data <- function(anova_list) {
  model.tables(anova_list) %>%
    as.data.frame() %>%
    mutate(
      contrast = rownames(.),
      estimate = `estimate`,
      lower    = `lower`,
      upper    = `upper`,
      p_value  = `p.value`,
      network = gsub("(.*)_(scale[15]):.*", "\\1", contrast),
      scale   = gsub(".*_(scale[15]):.*", "\\1", contrast),
      network_clean = case_when(
        network == "Cont" ~ "Control",
        network == "Default" ~ "Default Mode",
        network == "Limbic" ~ "Limbic",
        network == "DorsAttn" ~ "Dorsal Attention", 
        network == "SalVentAttn" ~ "Ventral Attention",
        network == "SomMot" ~ "Somatomotor",
        network == "Vis" ~ "Visual",
        TRUE ~ network
      ),
      sig_star = case_when(
        p_value < 0.001 ~ "***",
        p_value < 0.01  ~ "**",
        p_value < 0.05  ~ "*",
        TRUE            ~ ""
      ),
      network_clean = factor(network_clean, levels = c(
        "Control", "Default Mode", "Dorsal Attention", "Ventral Attention", 
        "Limbic", "Somatomotor", "Visual"
      ))
    )
}

# ---- Original distinguishable network colors ----
network_colors_orig <- c(
  "Control" = "#e74c3c",
  "Default Mode" = "#3498db",
  "Dorsal Attention" = "#2ecc71",
  "Limbic" = "#f39c12",
  "Ventral Attention" = "#9b59b6",
  "Somatomotor" = "#1abc9c",
  "Visual" = "#34495e"
)

# ---- Styling function ----
style_forest <- function(p) {
  p +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", alpha = 0.8) +
    scale_color_manual(values = network_colors_orig, guide = "none") +
    theme_classic(base_size = 12) +
    theme(
      strip.text = element_text(size = 14, face = "bold", color = "white"),
      strip.background = element_rect(fill = "gray30", color = "white", linewidth = 0.5),
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 30, hjust = 1, size = 11),
      axis.text.y = element_text(size = 11),
      panel.spacing = unit(1, "lines")
    )
}

# ---- Prepare forest data for all three ----
forest_data_stim <- prepare_forest_data(simple_list_stimulants)
forest_data_psy  <- prepare_forest_data(simple_list_psychedelics)
forest_data_contrast <- prepare_forest_data(simple_list)

# ---- Plot function with optional significance stars ----
plot_forest <- function(forest_data, title_text, sig_stars = FALSE) {
  
  p <- ggplot(forest_data, aes(x = network_clean, y = estimate, color = network_clean)) +
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
    geom_point(size = 4, shape = 16) +
    facet_wrap(~scale, nrow = 2, labeller = labeller(
      scale = c("scale1" = "Scale 1", "scale5" = "Scale 5")
    ))
  
  # Only add significance stars if requested
  if(sig_stars) {
    p <- p + geom_text(aes(y = upper + 0.0005, label = sig_star),
                       size = 5, color = "black", fontface = "bold")
  }
  
  # Apply style but keep facet labels visible
  p <- p + theme_classic(base_size = 12) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", alpha = 0.8) +
    scale_color_manual(values = network_colors_orig, guide = "none") +
    theme(
      strip.text = element_text(size = 14, face = "bold", color = "black"), # <- now visible
      strip.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
      axis.text.y = element_text(size = 11),
      panel.spacing = unit(1, "lines")
    )
  
  return(p)
}

# ---- Create separate plots ----
forest_stim <- plot_forest(forest_data_stim, "Stimulants vs Placebo", sig_stars = FALSE)
forest_psy  <- plot_forest(forest_data_psy, "Psychedelics vs Placebo", sig_stars = FALSE)
forest_contrast <- plot_forest(forest_data_contrast, "Psychedelics vs Stimulants", sig_stars = TRUE)

MSE_model_data <- rbind(forest_data_psy,forest_data_stim,forest_data_contrast)
MSE_model_data <- tibble(MSE_model_data)

# ---- Display plots ----
forest_stim
forest_psy
forest_contrast
grid.arrange(forest_stim,
forest_psy,
forest_contrast,ncol=3)
```



```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggpubr)

drug_order <- c("Placebo",  "Psilocybin", "LSD", "Mescaline","d-Amphetamine", "MDMA")
drug_colors <- c(
  "Placebo" = "#2c3e50",
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500"
)

scale1_cols <- grep("_scale1$", colnames(dd.entropy), value = TRUE) 
scale5_cols <- grep("_scale5$", colnames(dd.entropy), value = TRUE)

create_nn_plot <- function(networks_to_show = c("Cont", "Default", "DorsAttn"), scale_num = 1,
                           add_group_lines = TRUE, add_group_labels = TRUE, no_row = 4) {
  
  cols <- if (scale_num == 1) scale1_cols else scale5_cols
  cols_filtered <- cols[grepl(paste(networks_to_show, collapse = "|"), cols)]
  
  plot_data <- dd.entropy %>%
    select(drug, group, all_of(cols_filtered)) %>%
    pivot_longer(cols = all_of(cols_filtered), names_to = "network", values_to = "value") %>%
    mutate(
      network = gsub(paste0("_scale", scale_num), "", network),
      network = factor(network, levels = networks_to_show),  # ADD THIS LINE
      drug = factor(drug, levels = drug_order)
    ) %>%
    filter(!is.na(value))
  
    # First, calculate network-specific medians for placebo
    network_medians <- plot_data %>%
      filter(drug == 'Placebo') %>%
      group_by(network) %>%
      summarise(median_value = median(value, na.rm = TRUE), .groups = 'drop')
  
  p <- ggplot(plot_data, aes(x = drug, y = value, fill = drug)) +
    
    # Jittered points
    geom_jitter(aes(color = drug), width = 0.15, alpha = 0.6, size = 0.7, show.legend = FALSE) +
    
    # Boxplots
    geom_boxplot(outlier.shape = NA, width = 0.5, alpha = 0.8, color = "black", linewidth = 0.3) +
    
    scale_fill_manual(values = drug_colors, guide = "none") +
    scale_color_manual(values = drug_colors, guide = "none") +
    
    # Network-specific dashed reference lines
    geom_segment(data = network_medians, 
                 aes(x = 1.0, xend = 6.25, y = median_value, yend = median_value),
                 linetype = "dashed", color = "gray40", linewidth = 0.6, 
                 inherit.aes = FALSE) +
    
      
    facet_wrap(~network, nrow = no_row,
               labeller = labeller(network = c(
                 "Cont" = "Control", 
                 "Default" = "Default Mode",
                 "DorsAttn" = "Dorsal Attention",
                 "SalVentAttn" = "Ventral Attention",
                 "Vis" = "Visual",
                 "SomMot" = "Somatomotor "))) +
    
    labs(
      y = "Sample Entropy",
      x = NULL,
      title = paste("Scale", scale_num)
    ) +
    
    theme_classic(base_size = 13) +
    theme(
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
      axis.text.x = element_text(angle = 30, hjust = 1, size = 10),
      axis.text.y = element_text(size = 11),
      axis.title.y = element_text(size = 12, face = "bold"),
      strip.text = element_text(size = 13, face = "bold"),
      panel.spacing = unit(1.2, "lines")
    )
  
  # Option A: vertical separator lines between groups
  if (add_group_lines) {
    p <- p +
      geom_vline(xintercept = 1.5, linetype = "solid", color = "grey40", linewidth = 0.5) +
      geom_vline(xintercept = 4.5, linetype = "solid", color = "grey40", linewidth = 0.5)
  }
  
  # Option B: top labels for groups
  if (add_group_labels) {
    group_labels <- data.frame(
      network = rep(networks_to_show, each = 3),
      x = c(1, 2.5, 5),
      label = rep(c("", "Stimulants", "Psychedelics"), length(networks_to_show)),
      y = max(plot_data$value) + 0.0002
    )
    p <- p +
      geom_text(data = group_labels, aes(x = x, y = y, label = label),
                inherit.aes = FALSE, vjust = -0.5,
                fontface = "bold", size = 3, color = "black")
  }
  
  return(p)
}

# Examples
focused_scale1_higer <- create_nn_plot(c("Cont", "Default", "DorsAttn", "SalVentAttn"), 1,
                                 add_group_lines = TRUE, add_group_labels = FALSE, no_row = 4)

focused_scale5_higher <- create_nn_plot(c("Cont", "Default", "DorsAttn","SalVentAttn"), 5,
                                 add_group_lines = TRUE, add_group_labels = FALSE,no_row = 4)


focused_scale1_lower <- create_nn_plot(c("Vis", "SomMot", "Limbic"), 1,
                                 add_group_lines = TRUE, add_group_labels = FALSE, no_row = 3)

focused_scale5_lower <- create_nn_plot(c("Vis", "SomMot", "Limbic"), 5,
                                 add_group_lines = TRUE, add_group_labels = FALSE, no_row = 3)

# Higher order network 
gridExtra::grid.arrange(focused_scale1_higer, focused_scale5_higher, ncol = 2)

# Lower order network 
gridExtra::grid.arrange(focused_scale1_lower, focused_scale5_lower,ncol = 2)
```

Sample Entropy Generate drug compiarisons and giga plot the data
```{r}
# ---- Functions----
calculate_pairwise_estimates <- function(model) {
  estimate(model, f = function(p) {
      100 * c(
      PSI_vs_AMP = (p["sessionses_PSI"] - p["sessionses_AMP"]) / p["(Intercept)"],
      LSD_vs_AMP = (p["sessionses_LSD"] - p["sessionses_AMP"]) / p["(Intercept)"],
      MES_vs_AMP = (p["sessionses_MES"] - p["sessionses_AMP"]) / p["(Intercept)"],
      PSI_vs_MDA = (p["sessionses_PSI"] - p["sessionses_MDA"]) / p["(Intercept)"],
      LSD_vs_MDA = (p["sessionses_LSD"] - p["sessionses_MDA"]) / p["(Intercept)"],
      MES_vs_MDA = (p["sessionses_MES"] - p["sessionses_MDA"]) / p["(Intercept)"]
    )
  })
}

pairwise_results_MSE <- map(simple_model_lst, calculate_pairwise_estimates)
names(pairwise_results_MSE) <- network_scale_cols

# Function to extract the model estimates for each of the individual drugs and within class comparisons
calculate_estimates <- function(model) {
  estimate(model, f = function(p){
    100 * c(
      LSD = p["sessionses_LSD"] / p["(Intercept)"],
      PSI = p["sessionses_PSI"] / p["(Intercept)"],
      MES = p["sessionses_MES"] / p["(Intercept)"],
      MDMA = p["sessionses_MDA"] / p["(Intercept)"],
      AMP = p["sessionses_AMP"] / p["(Intercept)"],
      LSD_VS_PSI = (p["sessionses_LSD"] - p["sessionses_PSI"]) / p["(Intercept)"],
      LSD_VS_MES = (p["sessionses_LSD"] - p["sessionses_MES"]) / p["(Intercept)"],
      MES_VS_PSI = (p["sessionses_MES"] - p["sessionses_PSI"]) / p["(Intercept)"],
      MDMA_VS_AMP = (p["sessionses_MDA"] - p["sessionses_AMP"]) / p["(Intercept)"]
    )
  })
}

results_MSE <- map(simple_model_lst, calculate_estimates)
names(results_MSE) <- network_scale_cols

# ---- Prepare tidy dataframe (simple version) ----
prepare_estimates_df <- function(results_list, type_label) {
  map_df(names(results_list), function(name) {
    df <- as.data.frame(results_list[[name]])
    df$contrast <- rownames(results_list[[name]])
    df$network <- str_extract(name, "^[A-Za-z]+")      
    df$scale <- str_extract(name, "\\d+$")             
    df$type <- type_label
    df
  })
}

# Convert to tidy format
pairwise_df <- prepare_estimates_df(pairwise_results_MSE, "Between Drug Class")
single_df   <- prepare_estimates_df(results_MSE, "Drug Effect")

# --- Combine pairwise & single-drug results ---
combined_df <- bind_rows(pairwise_df, single_df)

# --- Map networks to full names ---
network_labels <- c(
  "Cont" = "Control",
  "Default" = "Default Mode",
  "Limbic" = "Limbic",
  "DorsAttn" = "Dorsal Attention", 
  "SalVentAttn" = "Ventral Attention",
  "SomMot" = "Somatomotor",
  "Vis" = "Visual"
)

combined_df <- combined_df %>%
  mutate(
    # Replace network codes with full names
    network_full = recode(network, !!!network_labels),
    # Extract just the contrast part before the first dot
    contrast_base = str_extract(contrast, "^[^.]+"),
    # Map to proper drug names
    contrast_clean = case_when(
      contrast_base == "PSI" ~ "Psilocybin",
      contrast_base == "LSD" ~ "LSD", 
      contrast_base == "MES" ~ "Mescaline",
      contrast_base == "AMP" ~ "d-Amphetamine",
      contrast_base == "MDMA" ~ "MDMA",
      contrast_base == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast_base == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast_base == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast_base == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast_base == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast_base == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast_base == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast_base == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast_base == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast_base == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast_base
    ),
    # Fix the type classification
    type = case_when(
      contrast_base %in% c("PSI", "LSD", "MES", "AMP", "MDMA") ~ "Drug Effect",
      contrast_base %in% c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    ),
    # Scale label
    scale_label = paste0("Scale ", scale)
  )

# Create the desired ordering
desired_order <- c(
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",  # Individual drugs
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",  # Within class
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine", 
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"  # Between class
)

combined_df$contrast_clean <- factor(combined_df$contrast_clean, levels = desired_order)

# Create color mapping - individual drugs get colors, contrasts are black
contrast_colors <- c(
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500", 
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black", 
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# Set the desired order for networks
network_order <- c("Control", "Default Mode", "Dorsal Attention", 
                   "Ventral Attention", "Limbic", "Somatomotor", "Visual")

# Convert network_full to factor with specified order
combined_df$network_full <- factor(combined_df$network_full, levels = network_order)

# Create the plot
p <- ggplot(combined_df, aes(x = contrast_clean, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical separating lines
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_point(aes(color = contrast_clean), size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper, color = contrast_clean), 
                width = 0.25, linewidth = 0.8) +
  scale_color_manual(values = contrast_colors) +
  facet_grid(network_full ~ scale_label, scales = "free_y", switch = "y") +
  labs(y = "Estimate (%)", x = NULL) +
  theme_classic(base_size = 13) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    strip.placement = "outside",
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    panel.spacing = unit(1, "lines")
  )

# Prepare the datafrma efor merge with the global metrics to create the giga table 
combined_df_merge <- combined_df %>% mutate(contrast = contrast_base) %>% mutate(variable = 'MSSE') %>% 
  select(variable, contrast, network, scale, estimate, se , df, lower, upper, p.value)

# ---- Clean up MSSE data ----
msse_clean <- combined_df_merge %>%
  select(variable, contrast, network, scale, estimate, se, df, lower, upper, p.value)

# ---- Add network and scale columns to global metrics (with NA) ----
combined_detailed_table <- combined_detailed_table %>%
  mutate(
    network = NA_character_,
    scale = NA
  )

# ---- Combine them ----
combined_detailed_table <- bind_rows(combined_detailed_table, msse_clean)

# View
print(combined_detailed_table)
print(table(combined_detailed_table$variable))
```

## This is for the NSCE ##
```{r}
# Extract the model results 
results <- model.tables(simple_list_ngse)
# Convert to data frame
forest_data_ngse <- data.frame(
  contrast = rownames(results),
  estimate = results[, "estimate"],
  lower = results[, "lower"], 
  upper = results[, "upper"],
  p_value = results[, "p.value"],
  stringsAsFactors = FALSE
) %>%
  # Parse the contrast names
  mutate(
    # Extract network and scale
    network = gsub(":.*", "", contrast),
    # Clean up network names
    network_clean = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "DorsAttn" ~ "Dorsal Attention", 
      network == "Limbic" ~ "Limbic",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Create significance indicator
    significant = p_value < 0.05,
    # Order networks consistently
    network_clean = factor(network_clean, levels = c(
      "Control", "Default Mode", "Dorsal Attention","Ventral Attention", "Limbic",
      "Somatomotor", "Visual"
    ))
  )

# Network colors
network_colors <- c(
  "Control" = "#e74c3c",
  "Default Mode" = "#3498db", 
  "Dorsal Attention" = "#2ecc71",
  "Limbic" = "#f39c12",
  "Ventral Attention" = "#9b59b6",
  "Somatomotor" = "#1abc9c",
  "Visual" = "#34495e"
)

# ---- Forest plot for NSGC ----
forest_ngse <- ggplot(forest_data_ngse, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16) +
  geom_text(aes(y = upper + 0.0005,   # <--- place at CI upper + offset
                label = ifelse(p_value < 0.001, "***",
                               ifelse(p_value < 0.01, "**",
                               ifelse(p_value < 0.05, "*", "")))),
            size = 5, color = "black", fontface = "bold")

forest_ngse <- style_forest(forest_ngse) 
print(forest_ngse)

# ---- PSYCHEDELICS ----
# Multivariate Wald Tests For Linear Mixed Model - Simple Models
simple_ano_lst_ngse_psychedelics <- lapply(simple_model_lst_ngse, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic" = " ((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) = 0")))
})
simple_list_ngse_psychedelics <- do.call("rbind", simple_ano_lst_ngse_psychedelics)

# Extract results for psychedelics
results_psychedelics <- model.tables(simple_list_ngse_psychedelics)
forest_data_ngse_psychedelics <- data.frame(
  contrast = rownames(results_psychedelics),
  estimate = results_psychedelics[, "estimate"],
  lower = results_psychedelics[, "lower"], 
  upper = results_psychedelics[, "upper"],
  p_value = results_psychedelics[, "p.value"],
  stringsAsFactors = FALSE
) %>%
  # Parse the contrast names
  mutate(
    # Extract network and scale
    network = gsub(":.*", "", contrast),
    # Clean up network names
    network_clean = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "DorsAttn" ~ "Dorsal Attention", 
      network == "Limbic" ~ "Limbic",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Create significance indicator
    significant = p_value < 0.05,
    # Order networks consistently
    network_clean = factor(network_clean, levels = c(
      "Control", "Default Mode", "Dorsal Attention","Ventral Attention", "Limbic",
      "Somatomotor", "Visual"
    ))
  )

# Forest plot for psychedelics (NO significance stars)
forest_ngse_psychedelics <- ggplot(forest_data_ngse_psychedelics, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16)

forest_ngse_psychedelics <- style_forest(forest_ngse_psychedelics) + ylim(-0.02,0.13)
print(forest_ngse_psychedelics)

# ---- STIMULANTS ----
# Multivariate Wald Tests For Linear Mixed Model - Simple Models
simple_ano_lst_ngse_stimulants <- lapply(simple_model_lst_ngse, function(i){
  return(anova(i, ci = TRUE, effect = c("groupstimulant" = "(sessionses_AMP + sessionses_MDA)/2 = 0")))
})
simple_list_ngse_stimulants <- do.call("rbind", simple_ano_lst_ngse_stimulants)

# Extract results for stimulants
results_stimulants <- model.tables(simple_list_ngse_stimulants)
forest_data_ngse_stimulants <- data.frame(
  contrast = rownames(results_stimulants),
  estimate = results_stimulants[, "estimate"],
  lower = results_stimulants[, "lower"], 
  upper = results_stimulants[, "upper"],
  p_value = results_stimulants[, "p.value"],
  stringsAsFactors = FALSE
) %>%
  # Parse the contrast names
  mutate(
    # Extract network and scale
    network = gsub(":.*", "", contrast),
    # Clean up network names
    network_clean = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "DorsAttn" ~ "Dorsal Attention", 
      network == "Limbic" ~ "Limbic",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Create significance indicator
    significant = p_value < 0.05,
    # Order networks consistently
    network_clean = factor(network_clean, levels = c(
      "Control", "Default Mode", "Dorsal Attention","Ventral Attention", "Limbic",
      "Somatomotor", "Visual"
    ))
  )

# Forest plot for stimulants (NO significance stars)
forest_ngse_stimulants <- ggplot(forest_data_ngse_stimulants, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16)

forest_ngse_stimulants <- style_forest(forest_ngse_stimulants)+ ylim(-0.02,0.13)
print(forest_ngse_stimulants)

# ---- Function to prepare minimal forest data ----
prepare_forest_data_simple <- function(model_list, contrast_name) {
  model.tables(model_list) %>%
    as.data.frame() %>%
    mutate(
      contrast = rownames(.),
      estimate = estimate,
      lower = lower,
      upper = upper,
      p_value = p.value,
      network = gsub(":.*", "", contrast),  # Extract network name before colon
      network_clean = case_when(
        network == "Cont" ~ "Control",
        network == "Default" ~ "Default Mode",
        network == "Limbic" ~ "Limbic",
        network == "DorsAttn" ~ "Dorsal Attention",
        network == "SalVentAttn" ~ "Ventral Attention",
        network == "SomMot" ~ "Somatomotor",
        network == "Vis" ~ "Visual",
        TRUE ~ network
      ),
      Contrast = contrast_name,
      # Order networks consistently
      network_clean = factor(network_clean, levels = c(
        "Control", "Default Mode", "Dorsal Attention", "Ventral Attention", "Limbic",
        "Somatomotor", "Visual"
      ))
    ) %>%
    select(Contrast, network_clean, estimate, lower, upper, p_value)
}

# ---- Prepare all three datasets ----
forest_data_stim <- prepare_forest_data_simple(simple_list_ngse_stimulants, "Stimulants vs Placebo")
forest_data_psy  <- prepare_forest_data_simple(simple_list_ngse_psychedelics, "Psychedelics vs Placebo")
forest_data_contrast <- prepare_forest_data_simple(simple_list_ngse, "Psychedelics vs Stimulants")

# ---- Combine into one table ----
forest_data_all <- bind_rows(forest_data_stim, forest_data_psy, forest_data_contrast) %>%
  mutate(
    Contrast = factor(Contrast, levels = c(
      "Stimulants vs Placebo", 
      "Psychedelics vs Placebo", 
      "Psychedelics vs Stimulants"
    ))
  )

# View the combined dataset
print(forest_data_all)

# Print the NGSC estimates to a datatable 
#write_xlsx(forest_data_all, "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/NGSC_forest_betas.xlsx")

grid.arrange(forest_ngse_stimulants,forest_ngse_psychedelics, forest_ngse)
```

Plot NSCE
```{r}
# Define networks in desired order
networks_to_show <- c("Cont", "Default", "DorsAttn", "SalVentAttn", "Limbic", "SomMot", "Vis")

# Prepare plot data
plot_data <- dd.ngse %>%
  select(drug, group, all_of(networks_to_show)) %>%
  pivot_longer(cols = all_of(networks_to_show), names_to = "network", values_to = "value") %>%
  mutate(
    drug = factor(drug, levels = drug_order),
    # Clean up network names and set factor levels in desired order
    network_clean = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "DorsAttn" ~ "Dorsal Attention", 
      network == "Limbic" ~ "Limbic",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    network_clean = factor(network_clean, levels = c(
      "Control", "Default Mode", "Dorsal Attention", "Ventral Attention", "Limbic",
      "Somatomotor", "Visual"
    ))
  ) %>%
  filter(!is.na(value))

# Calculate network-specific medians for placebo
network_medians <- plot_data %>%
  filter(drug == 'Placebo') %>%
  group_by(network_clean) %>%
  summarise(median_value = median(value, na.rm = TRUE), .groups = 'drop')

# Create the plot
p <- ggplot(plot_data, aes(x = drug, y = value, fill = drug)) +
  geom_jitter(aes(color = drug), width = 0.15, alpha = 0.6, size = 0.7, show.legend = FALSE) +
  geom_boxplot(outlier.shape = NA, width = 0.5, alpha = 0.8, color = "black", linewidth = 0.3) +
  scale_fill_manual(values = drug_colors, guide = "none") +
  scale_color_manual(values = drug_colors, guide = "none") +
  # Network-specific dashed reference lines
  geom_segment(data = network_medians, 
               aes(x = 1.0, xend = 6.25, y = median_value, yend = median_value),
               linetype = "dashed", color = "gray40", linewidth = 0.6, inherit.aes = FALSE) +
  # Facet with clean network names
  facet_wrap(~network_clean, nrow = 4, ncol = 2) +
  labs(
    y = "Network NSC",
    x = NULL
  ) +
  theme_classic(base_size = 13) +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1, size = 10),
    axis.text.y = element_text(size = 11),
    axis.title.y = element_text(size = 12, face = "bold"),
    strip.text = element_text(size = 13, face = "bold"),
    panel.spacing = unit(1.2, "lines")
  ) +
  # Add group separator lines
  geom_vline(xintercept = 1.5, linetype = "solid", color = "grey40", linewidth = 0.5) +
  geom_vline(xintercept = 4.5, linetype = "solid", color = "grey40", linewidth = 0.5)

# Display the plot
print(p)

```

Now for all contrasts comparisons for NSCE
```{r}
pairwise_results_NGSC <- map(simple_model_lst_ngse, calculate_pairwise_estimates)
names(pairwise_results_NGSC) <- networks

results_NGSC <- map(simple_model_lst_ngse, calculate_estimates)
names(results_NGSC) <- networks

# ---- Prepare tidy dataframe ----
prepare_estimates_df <- function(results_list, type_label) {
  map_df(names(results_list), function(name) {
    df <- as.data.frame(results_list[[name]])
    df$contrast <- rownames(results_list[[name]])
    df$network <- str_extract(name, "^[A-Za-z]+")      
    df$type <- type_label
    df
  })
}

# Convert to tidy format
pairwise_df <- prepare_estimates_df(pairwise_results_NGSC, "Between Drug Class")
single_df   <- prepare_estimates_df(results_NGSC, "Drug Effect")

# --- Combine pairwise & single-drug results ---
combined_df <- bind_rows(pairwise_df, single_df)

# --- Map networks to full names ---
network_labels <- c(
  "Cont" = "Control",
  "Default" = "Default Mode",
  "DorsAttn" = "Dorsal Attention", 
  "SalVentAttn" = "Ventral Attention",
  "Limbic" = "Limbic",
  "SomMot" = "Somatomotor",
  "Vis" = "Visual"
)

combined_df <- combined_df %>%
  mutate(
    # Replace network codes with full names
    network_full = recode(network, !!!network_labels),
    # Extract just the contrast part before the first dot
    contrast_base = str_extract(contrast, "^[^.]+"),
    # Map to proper drug names
    contrast_clean = case_when(
      contrast_base == "PSI" ~ "Psilocybin",
      contrast_base == "LSD" ~ "LSD", 
      contrast_base == "MES" ~ "Mescaline",
      contrast_base == "AMP" ~ "d-Amphetamine",
      contrast_base == "MDMA" ~ "MDMA",
      contrast_base == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast_base == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast_base == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast_base == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast_base == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast_base == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast_base == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast_base == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast_base == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast_base == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast_base
    ),
    # Fix the type classification
    type = case_when(
      contrast_base %in% c("PSI", "LSD", "MES", "AMP", "MDMA") ~ "Drug Effect",
      contrast_base %in% c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    )
  )

# Create the desired ordering
desired_order <- c(
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",  # Individual drugs
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",  # Within class
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine", 
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"  # Between class
)

combined_df$contrast_clean <- factor(combined_df$contrast_clean, levels = desired_order)

# Create color mapping - individual drugs get colors, contrasts are black
contrast_colors <- c(
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500", 
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black", 
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)
# Set the desired order for networks
network_order <- c("Control", "Default Mode", "Dorsal Attention", 
                   "Ventral Attention", "Limbic", "Somatomotor", "Visual")

# Convert network_full to factor with specified order
combined_df$network_full <- factor(combined_df$network_full, levels = network_order)

p <- ggplot(combined_df, aes(x = contrast_clean, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical separating lines
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_point(aes(color = contrast_clean), size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper, color = contrast_clean), 
                width = 0.25, linewidth = 0.8) +
  scale_color_manual(values = contrast_colors) +
  facet_wrap(~ network_full, ncol = 1, scales = "free_y", strip.position = "left") +
  labs(y = "Estimate (%)", x = NULL) +
  theme_classic(base_size = 13) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    strip.placement = "outside",
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    panel.spacing = unit(1, "lines")
  )
print(p)


# Now preparae the NGSC data for the merging with all the other
combined_df_NGSC <- combined_df

# Prepare the datafrma efor merge with the global metrics to create the giga table 
combined_df_merge <- combined_df_NGSC %>% mutate(contrast = contrast_base) %>% mutate(variable = 'NGSC') %>% 
  select(variable, contrast, network, estimate, se , df, lower, upper, p.value)

# ---- Clean up NGSC data ----
NGSC_clean <- combined_df_merge %>%
  select(variable, contrast, network, estimate, se, df, lower, upper, p.value) %>% mutate(scale = NA)

# ---- Combine them ----
combined_detailed_table <- bind_rows(combined_detailed_table, NGSC_clean)

# View
print(combined_detailed_table)
print(table(combined_detailed_table$variable))

```


DCC Entropy analysis
```{r}
simple_ano_lst_dcc_psychedelics <- lapply(simple_model_lst_DCC, function(i){
  return(anova(i, ci = TRUE, effect = c("grouppsychedelic" = " ((sessionses_LSD + sessionses_PSI + sessionses_MES) / 3) = 0")))
})
simple_list_dcc_psychedelics <- do.call("rbind", simple_ano_lst_dcc_psychedelics)

simple_ano_lst_dcc_stimulants <- lapply(simple_model_lst_DCC, function(i){
  return(anova(i, ci = TRUE, effect = c("groupstimulant" = "(sessionses_AMP + sessionses_MDA)/2 = 0")))
})
simple_list_dcc_stimulants <- do.call("rbind", simple_ano_lst_dcc_stimulants)

# Extract the model results for all three conditions
results <- model.tables(simple_list_dcc)
results_psychedelics <- model.tables(simple_list_dcc_psychedelics)
results_stimulants <- model.tables(simple_list_dcc_stimulants)

# Function to add significance stars
add_stars <- function(p_values) {
  stars <- case_when(
    p_values < 0.001 ~ "***",
    p_values < 0.01 ~ "**", 
    p_values < 0.05 ~ "*",
    p_values < 0.1 ~ "", 
    TRUE ~ ""
  )
  return(stars)
}


# Extract the model results for all three conditions
results <- model.tables(simple_list_dcc)
results_psychedelics <- model.tables(simple_list_dcc_psychedelics)
results_stimulants <- model.tables(simple_list_dcc_stimulants)

# Define the network labels and order (shortened for better readability)
network_labels <- c("Cont" = "CON",
                   "Default" = "DMN", 
                   "DorsAttn" = "DAN",
                   "SalVentAttn" = "VAN",
                   "Limbic" = "LIM",
                   "SomMot" = "SMN",
                   "Vis" = "VIS")
network_order <- names(network_labels)

# Function to process data for plotting
process_data <- function(results, condition_type, show_stars = TRUE) {
  # Convert to data frame
  df <- data.frame(
    contrast = rownames(results),
    estimate = results[, "estimate"],
    lower = results[, "lower"], 
    upper = results[, "upper"],
    p_value = results[, "p.value"],
    stringsAsFactors = FALSE
  ) 
  
  # Process the data with consistent network ordering
  df_processed <- df %>%
    mutate(
      # Add significance stars
      stars = add_stars(p_value),
      # Clean the contrast based on condition type
      contrast_clean = case_when(
        condition_type == "contrast" ~ str_remove(contrast, ": grouppsychedelic - groupstimulant"),
        condition_type == "psychedelics" ~ str_remove(contrast, ": grouppsychedelic"),
        condition_type == "stimulants" ~ str_remove(contrast, ": groupstimulant"),
        TRUE ~ contrast
      ),
      # Split into network1 and network2
      network1_raw = str_extract(contrast_clean, "^[^_]+"),
      network2_raw = str_extract(contrast_clean, "[^_]+$"),
      
      # Ensure consistent ordering for network pairs
      network1_idx = match(network1_raw, network_order),
      network2_idx = match(network2_raw, network_order),
      
      # For lower triangle: put the network with higher index as network1 (y-axis)
      # and the one with lower index as network2 (x-axis)
      network1 = ifelse(network1_idx >= network2_idx, network1_raw, network2_raw),
      network2 = ifelse(network1_idx >= network2_idx, network2_raw, network1_raw),
      
      # Create display text with conditional significance stars
      display_text = case_when(
        show_stars & abs(estimate) < 0.001 ~ paste0("<0.001", stars),
        show_stars ~ paste0(sprintf("%.3f", estimate), stars),
        abs(estimate) < 0.001 ~ "<0.001",
        TRUE ~ sprintf("%.3f", estimate)
      ),
      est_rounded = round(estimate, 3)
    ) %>%
    select(-network1_raw, -network2_raw, -network1_idx, -network2_idx)
  
  # Filter for lower triangle only
  df_lower <- df_processed %>%
    mutate(
      net1_idx = match(network1, network_order),
      net2_idx = match(network2, network_order)
    ) %>%
    filter(net1_idx >= net2_idx) %>%
    select(-net1_idx, -net2_idx)
  
  return(df_lower)
}

# Function to create publication-quality plot
create_plot <- function(df_lower, panel_label, fill_label) {
  p <- ggplot(df_lower, aes(x = network2, y = network1, fill = estimate)) +
    geom_tile(color = "white", linewidth = 0.8) +
    geom_text(aes(label = display_text), 
              color = "black", 
              size = 4.8, 
              fontface = "bold",
              family = "Arial") +
    scale_fill_gradient2(
      low = "#053061", 
      mid = "white", 
      high = "#67001F",
      midpoint = 0,
      name = fill_label,
      limits = c(-max_abs, max_abs),  # Consistent scale across plots
      breaks = scales::pretty_breaks(n = 5),
      labels = function(x) sprintf("%.3f", x),
      guide = guide_colorbar(
        title.position = "top",
        title.hjust = 0.5,
        barwidth = 0.8,
        barheight = 6,
        frame.colour = "black",
        frame.linewidth = 0.5
      )
    ) +
    scale_x_discrete(limits = network_order, labels = network_labels, position = "bottom") +
    scale_y_discrete(limits = rev(network_order), labels = network_labels) +
    labs(x = "", y = "", tag = panel_label) +
    theme_minimal(base_family = "Arial", base_size = 10) +
    theme(
      # Axes - no angle, bigger text
      axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 11, color = "black"),
      axis.text.y = element_text(hjust = 1, size = 11, color = "black"),
      
      # Legend
      legend.title = element_text(size = 9, face = "bold"),
      legend.text = element_text(size = 8),
      legend.position = "right",
      legend.margin = margin(l = 10),
      
      # Panel
      panel.grid = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      
      # Plot tag (panel label)
      plot.tag = element_text(size = 12, face = "bold", hjust = 0, vjust = 1),
      plot.tag.position = c(0.02, 0.98),
      
      # Margins
      plot.margin = margin(5, 5, 5, 5, "mm")
    ) +
    coord_fixed(expand = FALSE)
  
  return(p)
}

# Process data for all three conditions
df_contrast <- process_data(results, "contrast", show_stars = TRUE)
df_psychedelics <- process_data(results_psychedelics, "psychedelics", show_stars = FALSE)
df_stimulants <- process_data(results_stimulants, "stimulants", show_stars = FALSE)

# Calculate global range for consistent color scaling across ALL plots
df_all_data <- bind_rows(
  df_contrast %>% mutate(condition = "contrast"),
  df_psychedelics %>% mutate(condition = "psychedelics"), 
  df_stimulants %>% mutate(condition = "stimulants")
)
global_range <- range(df_all_data$estimate, na.rm = TRUE)
max_abs <- max(abs(global_range))

# Print the range for verification
cat("Global estimate range:", round(global_range, 4), "\n")
cat("Using symmetric scale from", round(-max_abs, 4), "to", round(max_abs, 4), "\n")

# Create publication-quality plots
p1 <- create_plot(df_contrast, "", "Difference\n(Psy − Stim)")
p2 <- create_plot(df_psychedelics, "", "Psychedelics")
p3 <- create_plot(df_stimulants, "", "Stimulants")


# Save individual plots
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_contrast.pdf", 
#        plot = p1, device = cairo_pdf, width = 10, height = 6, units = "in")
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_psychedelics.pdf", 
#        plot = p2, device = cairo_pdf, width = 10, height = 6, units = "in")  
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_stimulants.pdf", 
#        plot = p3, device = cairo_pdf, width = 10, height = 6, units = "in")

```


```{r}
# Network colors for the outer ring
network_colors <- c(
  "Cont" = "#E31A1C",           # Red
  "Default" = "#1F78B4",        # Blue  
  "DorsAttn" = "#33A02C",       # Green
  "Limbic" = "#FF7F00",         # Orange
  "SalVentAttn" = "#6A3D9A",    # Purple
  "SomMot" = "#A6CEE3",         # Light blue
  "Vis" = "#FDBF6F"             # Light orange
)

# Network name mapping from abbreviations to full names
network_name_map <- c(
  "Cont" = "CON",
  "Default" = "DMN", 
  "DorsAttn" = "DAN",
  "Limbic" = "LIM",
  "SalVentAttn" = "VAN",
  "SomMot" = "SMN",
  "Vis" = "VIS"
)

# Define network order for consistent positioning
network_order <- c("Vis", "SomMot", "DorsAttn", "SalVentAttn", "Limbic", "Cont", "Default")

# Create the chord diagram with gradient coloring
create_connectivity_plot <- function(data, plot_title = NULL) {
  
  # Check for required columns
  if (!"p_value" %in% colnames(data)) {
    stop("p_value column not found in data!")
  }
  if (!"est_rounded" %in% colnames(data)) {
    stop("est_rounded column not found in data!")
  }
  
  # Remove bidirectional duplicates
  data_with_pairs <- data %>%
    mutate(
      net_min = pmin(network1, network2),
      net_max = pmax(network1, network2),
      pair_id = paste(net_min, net_max, sep = "-"),
      is_self = (network1 == network2)
    )
  
  data_clean <- data_with_pairs %>%
    group_by(pair_id) %>%
    slice(1) %>%
    ungroup() %>%
    select(-net_min, -net_max, -pair_id)
  
  cat("\n=== Data Processing ===\n")
  cat("Original connections:", nrow(data), "\n")
  cat("After removing bidirectional duplicates:", nrow(data_clean), "\n")
  
  # Separate self vs between-network connections
  self_connections <- data_clean %>% filter(network1 == network2)
  between_connections <- data_clean %>% filter(network1 != network2)
  
  cat("Self-connections:", nrow(self_connections), "\n")
  cat("Between-network connections:", nrow(between_connections), "\n")
  
  # Count significant connections
  alpha_threshold <- 0.05
  n_significant <- sum(data_clean$p_value <= alpha_threshold)
  n_total <- nrow(data_clean)
  
  cat("\n=== Significance Summary ===\n")
  cat("Total unique connections:", n_total, "\n")
  cat("Significant connections (p ≤", alpha_threshold, "):", n_significant, "\n")
  cat("Non-significant connections:", n_total - n_significant, "\n")
  cat("Percentage significant:", round(100 * n_significant / n_total, 1), "%\n")
  
  # Effect size summary
  sig_data <- data_clean %>% filter(p_value <= alpha_threshold)
  if (nrow(sig_data) > 0) {
    cat("\n=== Effect Size Summary (Significant Only) ===\n")
    cat("Range: [", round(min(sig_data$est_rounded), 3), ",", 
        round(max(sig_data$est_rounded), 3), "]\n")
    cat("Mean:", round(mean(sig_data$est_rounded), 3), "\n")
    cat("Median:", round(median(sig_data$est_rounded), 3), "\n")
    
    pos_sig <- sum(sig_data$est_rounded > 0)
    neg_sig <- sum(sig_data$est_rounded < 0)
    cat("\nPositive effects:", pos_sig, 
        "(", round(100 * pos_sig / nrow(sig_data), 1), "%)\n")
    cat("Negative effects:", neg_sig, 
        "(", round(100 * neg_sig / nrow(sig_data), 1), "%)\n")
    
    cat("\n=== Top 10 Strongest Connections ===\n")
    top_connections <- sig_data %>% 
      arrange(desc(abs(est_rounded))) %>% 
      head(10)
    
    for(i in 1:nrow(top_connections)) {
      connection_type <- ifelse(top_connections$network1[i] == top_connections$network2[i], 
                                "within", "between")
      direction <- ifelse(top_connections$est_rounded[i] > 0, "↑", "↓")
      cat(sprintf("  %s %s ↔ %s: %.3f (p = %.4f) [%s]\n", 
                  direction,
                  top_connections$network1[i], 
                  top_connections$network2[i], 
                  top_connections$est_rounded[i], 
                  top_connections$p_value[i], 
                  connection_type))
    }
  }
  
  # Prepare all edges with gradient coloring
  chord_data <- data_clean %>%
    mutate(
      abs_beta = abs(est_rounded),
      beta_norm = (abs_beta - min(abs_beta)) / (max(abs_beta) - min(abs_beta)),
      base_color = ifelse(est_rounded > 0, "#67001F", "#053061"),  # Dark red for positive, dark blue for negative
      alpha = beta_norm^2 * 0.85 + 0.15  # Very close to original, just slightly more visible
    ) %>%
    arrange(desc(abs_beta))
  
  # Print value range for debugging
  cat("\nValue range in data:\n")
  cat("Min:", min(chord_data$est_rounded), "\n")
  cat("Max:", max(chord_data$est_rounded), "\n")
  cat("Mean:", mean(abs(chord_data$est_rounded)), "\n")
  
  # Create color vector with alpha
  edge_colors <- sapply(1:nrow(chord_data), function(i) {
    alpha(chord_data$base_color[i], chord_data$alpha[i])
  })
  
  # Set factor levels for ordering - THIS WAS MISSING!
  chord_data$network1 <- factor(chord_data$network1, levels = network_order)
  chord_data$network2 <- factor(chord_data$network2, levels = network_order)
  
  # Clear any previous plots
  circos.clear()
  
  # Set parameters
  circos.par(
    start.degree = 90, 
    gap.degree = 4
  )
  
  # Create chord diagram - use small constant value for thin chords
  # The value controls thickness; use a small constant to make all chords thin
  chord_data_for_plot <- chord_data
  chord_data_for_plot$const_val <- 0.001  # Very small constant for thin chords
  
  chordDiagram(
    chord_data_for_plot[, c("network1", "network2", "const_val")],
    order = network_order,
    col = edge_colors,
    grid.col = network_colors,
    directional = 0,
    annotationTrack = "grid",
    preAllocateTracks = list(track.height = 0.1)
  )
  
  # Add network labels with full names
  circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    # Map abbreviation to full name
    full_name <- network_name_map[sector.name]
    if(is.na(full_name)) full_name <- sector.name
    
    circos.text(mean(xlim), ylim[1], full_name,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),
                col = "black", font = 2, cex = 1.2)
  }, bg.border = NA)
  
  # Add title if provided
  if (!is.null(plot_title)) {
    title(main = plot_title, cex.main = 1.3, line = 1)
  }
  
  circos.clear()
}

# Dataset 1: Psychedelics vs Stimulants
if(exists("df_contrast")) {
  png("psychedelics_vs_stimulants.png", width = 2000, height = 2000, res = 300)
  par(mar = c(1, 1, 3, 1))
  create_connectivity_plot(df_contrast, "Psychedelics vs. Stimulants")
  dev.off()
  cat("\n✓ Created: psychedelics_vs_stimulants.png\n")
} else {
  cat("\n✗ df_contrast not found\n")
}

# Dataset 2: Psychedelics vs Placebo
if(exists("df_psychedelics")) {
  png("psychedelics_connectivity.png", width = 2000, height = 2000, res = 300)
  par(mar = c(1, 1, 3, 1))
  create_connectivity_plot(df_psychedelics, "Psychedelics vs. Placebo")
  dev.off()
  cat("\n✓ Created: psychedelics_connectivity.png\n")
} else {
  cat("\n✗ df_psychedelics not found\n")
}

# Dataset 3: Stimulants vs Placebo
if(exists("df_stimulants")) {
  png("stimulants_vs_placebo.png", width = 2000, height = 2000, res = 300)
  par(mar = c(1, 1, 3, 1))
  create_connectivity_plot(df_stimulants, "Stimulants vs. Placebo")
  dev.off()
  cat("\n✓ Created: stimulants_vs_placebo.png\n")
} else {
  cat("\n✗ df_stimulants not found\n")
}
```

All contrast comparison for DCC
```{r}
pairwise_results_DCC <- map(simple_model_lst_DCC, calculate_pairwise_estimates)
names(pairwise_results_DCC) <- dcc_networks

results_DCC <- map(simple_model_lst_DCC, calculate_estimates)
names(results_DCC) <- dcc_networks


# Convert to tidy format
pairwise_df <- prepare_estimates_df(pairwise_results_DCC, "Between Drug Class")
single_df   <- prepare_estimates_df(results_DCC, "Drug Effect")

# --- Combine pairwise & single-drug results ---
combined_df <- bind_rows(pairwise_df, single_df)

# Define the network labels and order (shortened for better readability)
network_labels <- c("Cont" = "CON",
                   "Default" = "DMN", 
                   "DorsAttn" = "DAN",
                   "SalVentAttn" = "VAN",
                   "Limbic" = "LIM",
                   "SomMot" = "SMN",
                   "Vis" = "VIS")
network_order <- names(network_labels)

# Function to extract and reshape DCC results for heatmap visualization
reshape_dcc_for_heatmap <- function(pairwise_results_DCC, results_DCC, dcc_networks) {
  
  # Step 1: Get all unique contrasts from both datasets
  all_contrasts_pairwise <- unique(unlist(lapply(pairwise_results_DCC, rownames)))
  all_contrasts_results <- unique(unlist(lapply(results_DCC, rownames)))
  all_contrasts <- unique(c(all_contrasts_pairwise, all_contrasts_results))
  
  # Step 2: Initialize matrices for each statistic
  # Assuming the columns are: estimate, se, df, lower, upper, p.value
  stats_to_extract <- c("estimate", "se", "df", "lower", "upper", "p.value")
  
  # Create empty matrices for each statistic
  matrices <- list()
  for (stat in stats_to_extract) {
    matrices[[stat]] <- matrix(NA, 
                              nrow = length(all_contrasts), 
                              ncol = length(dcc_networks),
                              dimnames = list(all_contrasts, dcc_networks))
  }
  
  # Step 3: Fill matrices with data from both sources
  for (network in dcc_networks) {
    
    # Check pairwise_results_DCC first
    if (network %in% names(pairwise_results_DCC)) {
      pairwise_data <- pairwise_results_DCC[[network]]
      if (!is.null(pairwise_data) && nrow(pairwise_data) > 0) {
        for (contrast in rownames(pairwise_data)) {
          for (stat in stats_to_extract) {
            if (stat %in% colnames(pairwise_data)) {
              matrices[[stat]][contrast, network] <- pairwise_data[contrast, stat]
            }
          }
        }
      }
    }
    
    # Check results_DCC (this will overwrite if same contrast exists in both)
    if (network %in% names(results_DCC)) {
      results_data <- results_DCC[[network]]
      if (!is.null(results_data) && nrow(results_data) > 0) {
        for (contrast in rownames(results_data)) {
          for (stat in stats_to_extract) {
            if (stat %in% colnames(results_data)) {
              matrices[[stat]][contrast, network] <- results_data[contrast, stat]
            }
          }
        }
      }
    }
  }
  
  return(matrices)
}

# Usage:
heatmap_data <- reshape_dcc_for_heatmap(pairwise_results_DCC, results_DCC, dcc_networks)

# Access individual matrices like:
estimates_matrix <- heatmap_data$estimate
pvalues_matrix <- heatmap_data$p.value

# Create separate matrices for different types of contrasts
separate_contrast_types <- function(heatmap_data) {
  
  # Get all contrast names
  all_contrasts <- rownames(heatmap_data$estimate)
  
  # Identify different types of contrasts
  individual_drugs <- grep("^[A-Z]+\\.sessionses_[A-Z]+$", all_contrasts, value = TRUE)
  pairwise_vs <- grep("_vs_.*\\.sessionses_", all_contrasts, value = TRUE)
  pairwise_VS <- grep("_VS_.*\\.sessionses_", all_contrasts, value = TRUE)
  
  # Create separate matrices for each type
  contrast_types <- list(
    individual = individual_drugs,
    pairwise_vs = pairwise_vs,
    pairwise_VS = pairwise_VS
  )
  
  # Extract subsets for each type
  separated_data <- list()
  for (contrast_type in names(contrast_types)) {
    contrasts_subset <- contrast_types[[contrast_type]]
    if (length(contrasts_subset) > 0) {
      separated_data[[contrast_type]] <- lapply(heatmap_data, function(mat) {
        mat[contrasts_subset, , drop = FALSE]
      })
    }
  }
  
  return(separated_data)
}

# Check for separated data:
separated_heatmap_data <- separate_contrast_types(heatmap_data)
individual_estimates <- separated_heatmap_data$individual$estimate
pairwise_estimates <- separated_heatmap_data$pairwise_vs$estimate

# Function to add significance stars
add_stars <- function(p_values) {
  case_when(
    p_values < 0.001 ~ "***",
    p_values < 0.01 ~ "**", 
    p_values < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Network order and labels
network_labels <- c("Cont" = "CON",
                   "Default" = "DMN", 
                   "DorsAttn" = "DAN",
                   "SalVentAttn" = "VAN",
                   "Limbic" = "LIM",
                   "SomMot" = "SMN",
                   "Vis" = "VIS")
network_order <- names(network_labels)

# Function to process DCC data for plotting
process_dcc_data <- function(estimate_matrix, pvalue_matrix, contrast_name, show_stars = TRUE) {
  
  # Convert matrices to long format
  estimate_long <- as.data.frame(as.table(estimate_matrix)) %>%
    rename(network_combo = Var2, contrast = Var1, estimate = Freq) %>%
    filter(!is.na(estimate))
  
  pvalue_long <- as.data.frame(as.table(pvalue_matrix)) %>%
    rename(network_combo = Var2, contrast = Var1, p_value = Freq) %>%
    filter(!is.na(p_value))
  
  # Merge estimate and p-value data
  df <- merge(estimate_long, pvalue_long, by = c("network_combo", "contrast"))
  
  # Filter for the specific contrast we want to plot
  df_contrast <- df %>%
    filter(contrast == contrast_name) %>%
    mutate(
      # Add significance stars
      stars = add_stars(p_value),
      
      # Split network combination into network1 and network2
      network1_raw = str_extract(network_combo, "^[^_]+"),
      network2_raw = str_extract(network_combo, "[^_]+$"),
      
      # Ensure consistent ordering for network pairs
      network1_idx = match(network1_raw, network_order),
      network2_idx = match(network2_raw, network_order),
      
      # For lower triangle: put the network with higher index as network1 (y-axis)
      # and the one with lower index as network2 (x-axis)
      network1 = ifelse(network1_idx >= network2_idx, network1_raw, network2_raw),
      network2 = ifelse(network1_idx >= network2_idx, network2_raw, network1_raw),
      
      # Create display text with conditional significance stars
      display_text = case_when(
        show_stars & abs(estimate) < 0.01 ~ paste0("<0.01%", stars),
        show_stars ~ paste0(sprintf("%.2f%%", estimate), stars),
        abs(estimate) < 0.01 ~ "<0.01%",
        TRUE ~ sprintf("%.2f%%", estimate)
      ),
      est_rounded = round(estimate, 2)
    ) %>%
    select(-network1_raw, -network2_raw, -network1_idx, -network2_idx)
  
  # Filter for lower triangle only (including diagonal)
  df_lower <- df_contrast %>%
    mutate(
      net1_idx = match(network1, network_order),
      net2_idx = match(network2, network_order)
    ) %>%
    filter(net1_idx >= net2_idx) %>%
    select(-net1_idx, -net2_idx)
  
  return(df_lower)
}

# Function to create DCC heatmap plot
create_dcc_plot <- function(df_lower, panel_label, fill_label, max_abs = NULL) {
  
  # Calculate max absolute value for consistent scaling if not provided
  if (is.null(max_abs)) {
    max_abs <- max(abs(df_lower$estimate), na.rm = TRUE)
  }
  
  p <- ggplot(df_lower, aes(x = network2, y = network1, fill = estimate)) +
    geom_tile(color = "white", linewidth = 0.8) +
    geom_text(aes(label = display_text), 
              color = "black", 
              size = 4.8, 
              fontface = "bold",
              family = "Arial") +
    scale_fill_gradient2(
      low = "#053061", 
      mid = "white", 
      high = "#67001F",
      midpoint = 0,
      name = fill_label,
      limits = c(-max_abs, max_abs),
      breaks = scales::pretty_breaks(n = 5),
      labels = function(x) sprintf("%.2f", x),
      guide = guide_colorbar(
        title.position = "top",
        title.hjust = 0.5,
        barwidth = 0.8,
        barheight = 6,
        frame.colour = "black",
        frame.linewidth = 0.5
      )
    ) +
    scale_x_discrete(limits = network_order, labels = network_labels, position = "bottom") +
    scale_y_discrete(limits = rev(network_order), labels = network_labels) +
    labs(x = "", y = "", tag = panel_label) +
    theme_minimal(base_family = "Arial", base_size = 10) +
    theme(
      # Axes - no angle, bigger text
      axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 11, color = "black"),
      axis.text.y = element_text(hjust = 1, size = 11, color = "black"),
      
      # Legend
      legend.title = element_text(size = 9, face = "bold"),
      legend.text = element_text(size = 8),
      legend.position = "right",
      legend.margin = margin(l = 10),
      
      # Panel
      panel.grid = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      
      # Plot tag (panel label)
      plot.tag = element_text(size = 12, face = "bold", hjust = 0, vjust = 1),
      plot.tag.position = c(0.02, 0.98),
      
      # Margins
      plot.margin = margin(5, 5, 5, 5, "mm")
    ) +
    coord_fixed(expand = FALSE)
  
  return(p)
}

# Function to create multiple heatmaps for different contrasts
create_multiple_dcc_heatmaps <- function(heatmap_data, contrasts_to_plot = NULL, 
                                       consistent_scale = TRUE, show_stars = FALSE) {
  
  # Get available contrasts if not specified
  if (is.null(contrasts_to_plot)) {
    contrasts_to_plot <- rownames(heatmap_data$estimate)[!is.na(rowSums(heatmap_data$estimate, na.rm = TRUE))]
  }
  
  # Calculate global max for consistent scaling
  if (consistent_scale) {
    global_max <- max(abs(heatmap_data$estimate), na.rm = TRUE)
  } else {
    global_max <- NULL
  }
  
  # Create list to store plots
  plots <- list()
  
  # Generate plot for each contrast
  for (i in seq_along(contrasts_to_plot)) {
    contrast <- contrasts_to_plot[i]
    
    # Process data for this contrast
    df_lower <- process_dcc_data(
      heatmap_data$estimate, 
      heatmap_data$p.value, 
      contrast, 
      show_stars = show_stars
    )
    
    # Skip if no data
    if (nrow(df_lower) == 0) {
      warning(paste("No data found for contrast:", contrast))
      next
    }
    
    # Create panel label
    panel_label <- LETTERS[i]
    
    # Clean contrast name for title
    clean_contrast <- str_replace_all(contrast, "_", " ")
    clean_contrast <- str_replace(clean_contrast, "\\.sessionses", "")
    
    # Create plot
    if (consistent_scale) {
      plot_max <- global_max
    } else {
      plot_max <- max(abs(df_lower$estimate), na.rm = TRUE)
    }
    
    p <- create_dcc_plot(
      df_lower, 
      panel_label, 
      "Estimate",
      max_abs = plot_max
    ) +
      ggtitle(clean_contrast)
    
    plots[[contrast]] <- p
  }
  
  return(plots)
}

# Convenience function to plot individual contrasts by type
plot_contrasts_by_type <- function(heatmap_data, contrast_type = "all") {
  
  all_contrasts <- rownames(heatmap_data$estimate)
  
  # Filter contrasts by type
  if (contrast_type == "individual") {
    contrasts <- grep("^[A-Z]+\\.sessionses_[A-Z]+$", all_contrasts, value = TRUE)
  } else if (contrast_type == "pairwise_vs") {
    contrasts <- grep("_vs_.*\\.sessionses_", all_contrasts, value = TRUE)
  } else if (contrast_type == "pairwise_VS") {
    contrasts <- grep("_VS_.*\\.sessionses_", all_contrasts, value = TRUE)
  } else {
    contrasts <- all_contrasts
  }
  
  # Remove contrasts with all NA values
  contrasts <- contrasts[!is.na(rowSums(heatmap_data$estimate[contrasts, , drop = FALSE], na.rm = TRUE))]
  
  return(create_multiple_dcc_heatmaps(heatmap_data, contrasts))
}

# Usage examples:
# 
# # Create heatmap data first
heatmap_data <- reshape_dcc_for_heatmap(pairwise_results_DCC, results_DCC, dcc_networks)
# 
# # Plot all individual drug contrasts
individual_plots <- plot_contrasts_by_type(heatmap_data, "individual")

# 
# # Plot all pairwise comparisons
pairwise_plots <- plot_contrasts_by_type(heatmap_data, "pairwise_vs")
# 
# # Plot specific contrasts
specific_contrasts <- c("AMP.sessionses_AMP", "MDMA.sessionses_MDA")
specific_plots <- create_multiple_dcc_heatmaps(heatmap_data, specific_contrasts)

# Function to save all DCC plots as PDFs
save_dcc_plots_as_pdf <- function(plot_list, base_path, width = 8, height = 6) {
  
  # Create directory if it doesn't exist
  dir.create(dirname(base_path), recursive = TRUE, showWarnings = FALSE)
  
  # Loop through each plot and save
  for (contrast_name in names(plot_list)) {
    # Clean the contrast name for filename (remove special characters)
    clean_name <- gsub("[^A-Za-z0-9_]", "_", contrast_name)
    clean_name <- gsub("_{2,}", "_", clean_name)  # Replace multiple underscores with single
    clean_name <- gsub("_$", "", clean_name)     # Remove trailing underscore
    
    # Create full filepath
    filepath <- file.path(dirname(base_path), 
                         paste0("DCC_heatmap_", clean_name, ".pdf"))
    
    # Save plot
    ggsave(filepath, 
           plot = plot_list[[contrast_name]], 
           device = cairo_pdf, 
           width = width, 
           height = height, 
           units = "in")
    
    cat("Saved:", filepath, "\n")
  }
}

# Usage:
base_path <- "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/"

#  save all plots at once
all_plots <- create_multiple_dcc_heatmaps(heatmap_data)
save_dcc_plots_as_pdf(all_plots, base_path)



## Here we prepare the DCC for the full merge now handle the base name
combined_df_DCC <- combined_df %>% mutate(contrast = str_extract(contrast, "^[^.]+"))

# Prepare the datafrma efor merge with the global metrics to create the giga table 
combined_df_merge <- combined_df_DCC%>% mutate(variable = 'DCC') %>% 
  select(variable, contrast, network, estimate, se , df, lower, upper, p.value)

# ---- Clean up NGSC data ----
NGSC_clean <- combined_df_merge %>%
  select(variable, contrast, network, estimate, se, df, lower, upper, p.value) %>% mutate(scale = NA)

# ---- Combine them ----
combined_detailed_table <- bind_rows(combined_detailed_table, NGSC_clean)

# View
print(combined_detailed_table)
print(table(combined_detailed_table$variable))

```

All contrast circle generation code for DCC
```{r}
# Required libraries
library(circlize)
library(dplyr)
library(scales)

# Network colors for the outer ring
network_colors <- c(
  "Cont" = "#E31A1C",           # Red
  "Default" = "#1F78B4",        # Blue  
  "DorsAttn" = "#33A02C",       # Green
  "Limbic" = "#FF7F00",         # Orange
  "SalVentAttn" = "#6A3D9A",    # Purple
  "SomMot" = "#A6CEE3",         # Light blue
  "Vis" = "#FDBF6F"             # Light orange
)

# Network name mapping (same as heatmap)
network_name_map <- c(
  "Cont" = "CON",
  "Default" = "DMN", 
  "DorsAttn" = "DAN",
  "Limbic" = "LIM",
  "SalVentAttn" = "VAN",
  "SomMot" = "SMN",
  "Vis" = "VIS"
)

# Define network order for consistent positioning
network_order <- c("Vis", "SomMot", "DorsAttn", "SalVentAttn", "Limbic", "Cont", "Default")

# Function to prepare DCC data for chord diagram
prepare_dcc_chord_data <- function(estimate_matrix, pvalue_matrix, contrast_name) {
  
  # Convert matrices to long format
  estimate_long <- as.data.frame(as.table(estimate_matrix)) %>%
    rename(network_combo = Var2, contrast = Var1, estimate = Freq) %>%
    filter(!is.na(estimate))
  
  pvalue_long <- as.data.frame(as.table(pvalue_matrix)) %>%
    rename(network_combo = Var2, contrast = Var1, p_value = Freq) %>%
    filter(!is.na(p_value))
  
  # Merge estimate and p-value data
  df <- merge(estimate_long, pvalue_long, by = c("network_combo", "contrast"))
  
  # Filter for the specific contrast
  df_contrast <- df %>%
    filter(contrast == contrast_name) %>%
    mutate(
      # Split network combination into network1 and network2
      network1 = str_extract(network_combo, "^[^_]+"),
      network2 = str_extract(network_combo, "[^_]+$"),
      est_rounded = round(estimate, 3)
    ) %>%
    select(network1, network2, estimate, p_value, est_rounded)
  
  return(df_contrast)
}

# Main function to create chord diagram for DCC data
create_dcc_chord_diagram <- function(estimate_matrix, pvalue_matrix, contrast_name, 
                                   plot_title = NULL, alpha = 0.05) {
  
  # Prepare data
  data <- prepare_dcc_chord_data(estimate_matrix, pvalue_matrix, contrast_name)
  
  if (nrow(data) == 0) {
    warning(paste("No data found for contrast:", contrast_name))
    return(NULL)
  }
  
  # Create plot title if not provided
  if (is.null(plot_title)) {
    plot_title <- gsub("_", " ", contrast_name)
    plot_title <- gsub("\\.sessionses", "", plot_title)
  }
  
  # Remove bidirectional duplicates
  data_with_pairs <- data %>%
    mutate(
      net_min = pmin(network1, network2),
      net_max = pmax(network1, network2),
      pair_id = paste(net_min, net_max, sep = "-"),
      is_self = (network1 == network2)
    )
  
  data_clean <- data_with_pairs %>%
    group_by(pair_id) %>%
    slice(1) %>%
    ungroup() %>%
    select(-net_min, -net_max, -pair_id)
  
  cat("\n=== Data Processing ===\n")
  cat("Processing contrast:", contrast_name, "\n")
  cat("Original connections:", nrow(data), "\n")
  cat("After removing bidirectional duplicates:", nrow(data_clean), "\n")
  
  # Separate self vs between-network connections
  self_connections <- data_clean %>% filter(network1 == network2)
  between_connections <- data_clean %>% filter(network1 != network2)
  
  cat("Self-connections:", nrow(self_connections), "\n")
  cat("Between-network connections:", nrow(between_connections), "\n")
  
  # Count significant connections
  n_significant <- sum(data_clean$p_value <= alpha)
  n_total <- nrow(data_clean)
  
  cat("\n=== Significance Summary ===\n")
  cat("Total unique connections:", n_total, "\n")
  cat("Significant connections (p ≤", alpha, "):", n_significant, "\n")
  cat("Non-significant connections:", n_total - n_significant, "\n")
  cat("Percentage significant:", round(100 * n_significant / n_total, 1), "%\n")
  
  # Effect size summary
  sig_data <- data_clean %>% filter(p_value <= alpha)
  if (nrow(sig_data) > 0) {
    cat("\n=== Effect Size Summary (Significant Only) ===\n")
    cat("Range: [", round(min(sig_data$est_rounded), 3), ",", 
        round(max(sig_data$est_rounded), 3), "]\n")
    cat("Mean:", round(mean(sig_data$est_rounded), 3), "\n")
    cat("Median:", round(median(sig_data$est_rounded), 3), "\n")
    
    pos_sig <- sum(sig_data$est_rounded > 0)
    neg_sig <- sum(sig_data$est_rounded < 0)
    cat("\nPositive effects:", pos_sig, 
        "(", round(100 * pos_sig / nrow(sig_data), 1), "%)\n")
    cat("Negative effects:", neg_sig, 
        "(", round(100 * neg_sig / nrow(sig_data), 1), "%)\n")
    
    cat("\n=== Top 10 Strongest Connections ===\n")
    top_connections <- sig_data %>% 
      arrange(desc(abs(est_rounded))) %>% 
      head(10)
    
    for(i in 1:nrow(top_connections)) {
      connection_type <- ifelse(top_connections$network1[i] == top_connections$network2[i], 
                                "within", "between")
      direction <- ifelse(top_connections$est_rounded[i] > 0, "↑", "↓")
      cat(sprintf("  %s %s ↔ %s: %.3f (p = %.4f) [%s]\n", 
                  direction,
                  top_connections$network1[i], 
                  top_connections$network2[i], 
                  top_connections$est_rounded[i], 
                  top_connections$p_value[i], 
                  connection_type))
    }
  }
  
  # Prepare all edges with gradient coloring - EXACTLY like first code
  chord_data <- data_clean %>%
    mutate(
      abs_beta = abs(est_rounded),
      beta_norm = (abs_beta - min(abs_beta)) / (max(abs_beta) - min(abs_beta)),
      base_color = ifelse(est_rounded > 0, "#67001F", "#053061"),  # Dark red for positive, dark blue for negative
      alpha = beta_norm^2 * 0.85 + 0.15  # Very close to original, just slightly more visible
    ) %>%
    arrange(desc(abs_beta))
  
  # Print value range for debugging
  cat("\nValue range in data:\n")
  cat("Min:", min(chord_data$est_rounded), "\n")
  cat("Max:", max(chord_data$est_rounded), "\n")
  cat("Mean:", mean(abs(chord_data$est_rounded)), "\n")
  
  # Create color vector with alpha
  edge_colors <- sapply(1:nrow(chord_data), function(i) {
    alpha(chord_data$base_color[i], chord_data$alpha[i])
  })
  
  # Set factor levels for ordering - THIS IS CRITICAL!
  chord_data$network1 <- factor(chord_data$network1, levels = network_order)
  chord_data$network2 <- factor(chord_data$network2, levels = network_order)
  
  # Clear any previous plots
  circos.clear()
  
  # Set parameters - matching first code
  circos.par(
    start.degree = 90, 
    gap.degree = 4
  )
  
  # Create chord diagram - use small constant value for thin chords
  # The value controls thickness; use a small constant to make all chords thin
  chord_data_for_plot <- chord_data
  chord_data_for_plot$const_val <- 0.001  # Very small constant for thin chords
  
  chordDiagram(
    chord_data_for_plot[, c("network1", "network2", "const_val")],
    order = network_order,
    col = edge_colors,
    grid.col = network_colors,
    directional = 0,
    annotationTrack = "grid",
    preAllocateTracks = list(track.height = 0.1)
  )
  
  # Add network labels with full names - matching first code
  circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    # Map abbreviation to full name
    full_name <- network_name_map[sector.name]
    if(is.na(full_name)) full_name <- sector.name
    
    circos.text(mean(xlim), ylim[1], full_name,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),
                col = "black", font = 2, cex = 1.2)
  }, bg.border = NA)
  
  # Add title
  if (!is.null(plot_title)) {
    title(main = plot_title, cex.main = 1.3, line = 1)
  }
  
  circos.clear()
  
  return(data_clean)  # Return the processed data for reference
}

# Function to create chord diagrams for multiple contrasts
create_multiple_dcc_chords <- function(heatmap_data, contrasts_to_plot = NULL, 
                                     save_plots = FALSE, output_dir = NULL) {
  
  # Get available contrasts
  if (is.null(contrasts_to_plot)) {
    contrasts_to_plot <- rownames(heatmap_data$estimate)[!is.na(rowSums(heatmap_data$estimate, na.rm = TRUE))]
  }
  
  # Set up output directory if saving
  if (save_plots && !is.null(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  
  results <- list()
  
  # Generate chord diagram for each contrast
  for (contrast in contrasts_to_plot) {
    
    cat("\n========================================\n")
    cat("=== Processing:", contrast, "===\n")
    
    # Clean contrast name for title and filename
    clean_contrast <- str_replace_all(contrast, "_", " ")
    clean_contrast <- str_replace(clean_contrast, "\\.sessionses", "")
    
    if (save_plots && !is.null(output_dir)) {
      # Create filename
      clean_filename <- gsub("[^A-Za-z0-9_]", "_", contrast)
      clean_filename <- gsub("_{2,}", "_", clean_filename)
      clean_filename <- gsub("_$", "", clean_filename)
      filepath <- file.path(output_dir, paste0("DCC_chord_", clean_filename, ".png"))
      
      # Start PNG device with same resolution as first code
      png(filepath, width = 2000, height = 2000, res = 300)
      par(mar = c(1, 1, 3, 1))
    }
    
    # Create the chord diagram
    result_data <- create_dcc_chord_diagram(
      heatmap_data$estimate, 
      heatmap_data$p.value, 
      contrast,
      plot_title = clean_contrast
    )
    
    if (save_plots && !is.null(output_dir)) {
      dev.off()
      cat("\n✓ Saved:", filepath, "\n")
    }
    
    results[[contrast]] <- result_data
  }
  
  return(results)
}

# Convenience function to create chord diagrams by contrast type
create_dcc_chords_by_type <- function(heatmap_data, contrast_type = "all", 
                                    save_plots = FALSE, output_dir = NULL) {
  
  all_contrasts <- rownames(heatmap_data$estimate)
  
  # Filter contrasts by type
  if (contrast_type == "individual") {
    contrasts <- grep("^[A-Z]+\\.sessionses_[A-Z]+$", all_contrasts, value = TRUE)
  } else if (contrast_type == "pairwise_vs") {
    contrasts <- grep("_vs_.*\\.sessionses_", all_contrasts, value = TRUE)
  } else if (contrast_type == "pairwise_VS") {
    contrasts <- grep("_VS_.*\\.sessionses_", all_contrasts, value = TRUE)
  } else {
    contrasts <- all_contrasts
  }
  
  # Remove contrasts with all NA values
  contrasts <- contrasts[!is.na(rowSums(heatmap_data$estimate[contrasts, , drop = FALSE], na.rm = TRUE))]
  
  return(create_multiple_dcc_chords(heatmap_data, contrasts, save_plots, output_dir))
}

# Usage:
#
# # Create chord diagrams for individual drug effects
# individual_chords <- create_dcc_chords_by_type(heatmap_data, "individual", 
#                                               save_plots = TRUE, 
#                                               output_dir = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/")
#
# # Create chord diagrams for pairwise comparisons
pairwise_chords <- create_dcc_chords_by_type(heatmap_data, "pairwise_vs",
                                             save_plots = TRUE,
                                             output_dir = base_path)
```


FWER correction with HOLM all test combined 
```{r}
############# Psychedelics vs. stimulants ############
# Combine all the lists first to get all 53 tests in the same data for all contrasts
all_ano_lst <- c(simple_ano_lst, simple_ano_lst_ngse, simple_ano_lst_dcc,anova_results)

# Then rbind once to create a single Wald_lmm object
simple_combined <- do.call("rbind", all_ano_lst)

# Save the combined object
# saveRDS(simple_combined, file = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined.rds")

# Load it back
simple_combined <- readRDS("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined.rds")

# Correct for multiple comparisons
summary(simple_combined, method = 'holm')

####### Psychedelics vs placebo ###############
# Combine all the lists first
all_ano_lst_psychedelics <- c(simple_ano_lst_psychedelics, simple_ano_lst_ngse_psychedelics, simple_ano_lst_dcc_psychedelics,anova_results_psychedelics_only)

# Then rbind once to create a single Wald_lmm object
simple_combined_psychedelics <- do.call("rbind", all_ano_lst_psychedelics)

# Save the combined object
# saveRDS(simple_combined_psychedelics, file = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined_psychedelics.rds")

# Load it back
simple_combined_psychedelics <- readRDS("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined_psychedelics.rds")
# Correct for multiple comparisons
summary(simple_combined_psychedelics, method = 'holm')

################# Stimulants vs placebo ######################
# Combine all the lists first
all_ano_lst_stimulants <- c(simple_ano_lst_stimulants, simple_ano_lst_ngse_stimulants, simple_ano_lst_dcc_stimulants,anova_results_stimulants_only)

# Then rbind once to create a single Wald_lmm object
simple_combined_stimulants <- do.call("rbind", all_ano_lst_stimulants)

# Correct for multiple comparisons
summary(simple_combined_stimulants, method = 'holm')


#saveRDS(simple_combined_stimulants, file = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined_stimulants.rds")

simple_combined_stimulants <- readRDS("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/simple_combined_stimulants.rds")


# To get both the uncorrected at the corrected values for the tables
model.tables(simple_combined, method = 'none')
model.tables(simple_combined_stimulants, method = 'none')
model.tables(simple_combined_psychedelics, method = 'none')

model.tables(simple_combined, method = 'holm')
model.tables(simple_combined_stimulants, method = 'holm')
model.tables(simple_combined_psychedelics, method = 'holm')

# Function to extract and combine model tables
extract_model_results <- function(model_obj, contrast_name) {
  
  # Extract 'none' method results (has CIs and uncorrected p-values)
  results_none <- as.data.frame(model.tables(model_obj, method = 'none'))
  results_none$test_name <- rownames(results_none)
  
  # Extract 'holm' method results (has corrected p-values)
  results_holm <- as.data.frame(model.tables(model_obj, method = 'holm'))
  results_holm$test_name <- rownames(results_holm)
  
  # Combine: take everything from 'none' and add p_holm from 'holm'
  combined <- results_none
  combined$p_holm <- results_holm$p.value[match(combined$test_name, results_holm$test_name)]
  
  # Rename p.value to p_uncorrected for clarity
  names(combined)[names(combined) == "p.value"] <- "p_uncorrected"
  
  # Add contrast information
  combined$contrast <- contrast_name
  
  return(combined)
}

add_metadata <- function(df) {
  
  df$metric_type <- NA
  df$network_1 <- NA
  df$network_2 <- NA
  
  for (i in 1:nrow(df)) {
    test <- df$test_name[i]
    
    # Extract the part before the colon (the actual test identifier)
    test_parts <- strsplit(test, ":")[[1]]
    test_id <- trimws(test_parts[1])
    
    # MSE Scale 1
    if (grepl("_scale1$", test_id)) {
      df$metric_type[i] <- "MSE_scale1"
      df$network_1[i] <- gsub("_scale1$", "", test_id)
    }
    # MSE Scale 5
    else if (grepl("_scale5$", test_id)) {
      df$metric_type[i] <- "MSE_scale5"
      df$network_1[i] <- gsub("_scale5$", "", test_id)
    }
    # Special metrics - CHECK THESE FIRST before DCC!
    else if (test_id == "LZ_entropy") {
      df$metric_type[i] <- "LZ"
      df$network_1[i] <- "global"
    }
    else if (test_id == "metaState") {
      df$metric_type[i] <- "metaState"
      df$network_1[i] <- "global"
    }
    else if (test_id == "modularity_norm") {
      df$metric_type[i] <- "modularity"
      df$network_1[i] <- "global"
    }
    else if (test_id == "ngsc_global") {
      df$metric_type[i] <- "NGSC_global"
      df$network_1[i] <- "global"
    }
    # DCC (has underscore between two network names, but not scale)
    # This must come AFTER special metrics check
    else if (grepl("_", test_id) && !grepl("scale", test_id)) {
      df$metric_type[i] <- "DCC"
      networks <- strsplit(test_id, "_")[[1]]
      df$network_1[i] <- networks[1]
      df$network_2[i] <- networks[2]
    }
    # NGSC (single network names without underscore or scale)
    else if (!grepl("_", test_id) && !grepl("scale", test_id) && 
             test_id %in% c("Cont", "Default", "DorsAttn", "Limbic", 
                           "SalVentAttn", "SomMot", "Vis")) {
      df$metric_type[i] <- "NGSC"
      df$network_1[i] <- test_id
    }
  }
  
  return(df)
}

# Extract results from all three models
results_psychVstim <- extract_model_results(simple_combined, "psychedelic_vs_stimulant")
results_stimVplacebo <- extract_model_results(simple_combined_stimulants, "stimulant_vs_placebo")
results_psychVplacebo <- extract_model_results(simple_combined_psychedelics, "psychedelic_vs_placebo")

# Combine all results
mega_table <- rbind(results_psychVstim, results_stimVplacebo, results_psychVplacebo)

# Add metadata
mega_table <- add_metadata(mega_table)

# Verify it worked
table(mega_table$metric_type, useNA = "ifany")

# Reorder columns for better readability
mega_table <- mega_table[, c("test_name", "contrast", "metric_type", "network_1", "network_2",
                             "estimate", "se", "df", "lower", "upper", 
                             "p_uncorrected", "p_holm")]

# View the structure
print(head(mega_table, 20))
print(table(mega_table$metric_type))
print(table(mega_table$contrast))
# Save to CSV for inspection
# write.csv(mega_table, "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/data/mega_results_table.csv", row.names = FALSE)
```


Make the plots for the MSSE based on the table with all the contrast which has been correct with Holm-Bonferroni
```{r}
# ---- Function to prepare forest data from mega_table ----
prepare_forest_data_from_mega <- function(mega_table, contrast_name) {
  
  # Filter for the specific contrast and MSE metrics only
  df <- mega_table %>%
    filter(contrast == contrast_name,
           metric_type %in% c("MSE_scale1", "MSE_scale5")) %>%
    mutate(
      network = network_1,
      scale = ifelse(metric_type == "MSE_scale1", "scale1", "scale5"),
      network_clean = case_when(
        network == "Cont" ~ "Control",
        network == "Default" ~ "Default Mode",
        network == "Limbic" ~ "Limbic",
        network == "DorsAttn" ~ "Dorsal Attention", 
        network == "SalVentAttn" ~ "Ventral Attention",
        network == "SomMot" ~ "Somatomotor",
        network == "Vis" ~ "Visual",
        TRUE ~ network
      ),
      sig_star = case_when(
        p_holm < 0.001 ~ "***",
        p_holm < 0.01  ~ "**",
        p_holm < 0.05  ~ "*",
        TRUE            ~ ""
      ),
      network_clean = factor(network_clean, levels = c(
        "Control", "Default Mode", "Dorsal Attention", "Ventral Attention", 
        "Limbic", "Somatomotor", "Visual"
      ))
    )
  
  return(df)
}

# ---- Original distinguishable network colors ----
network_colors_orig <- c(
  "Control" = "#e74c3c",
  "Default Mode" = "#3498db",
  "Dorsal Attention" = "#2ecc71",
  "Limbic" = "#f39c12",
  "Ventral Attention" = "#9b59b6",
  "Somatomotor" = "#1abc9c",
  "Visual" = "#34495e"
)

# ---- Plot function with optional significance stars ----
plot_forest <- function(forest_data, title_text, sig_stars = FALSE) {
  
  # Calculate y-axis limits per scale with different expansions
  limits_df <- forest_data %>%
    group_by(scale) %>%
    summarise(
      y_min = min(lower, na.rm = TRUE),
      y_max = max(upper, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(
      # For scale1: less space at bottom (5%), more at top (20%)
      # For scale5: more space at bottom (20%), less at top (5%)
      range = y_max - y_min,
      expand_bottom = ifelse(scale == "scale1", 0.05, 0.20),
      expand_top = ifelse(scale == "scale1", 0.20, 0.05),
      lim_min = y_min - (range * expand_bottom),
      lim_max = y_max + (range * expand_top)
    )
  
  # Join limits back to data
  forest_data <- forest_data %>%
    left_join(limits_df %>% select(scale, lim_min, lim_max), by = "scale")
  
  p <- ggplot(forest_data, aes(x = network_clean, y = estimate, color = network_clean)) +
    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
    geom_point(size = 4, shape = 16) +
    facet_wrap(~scale, nrow = 2, scales = "free_y", labeller = labeller(
      scale = c("scale1" = "Scale 1", "scale5" = "Scale 5")
    ))
  
  # Only add significance stars if requested
  if(sig_stars) {
    p <- p + geom_text(aes(y = upper + 0.0019, label = sig_star),
                       size = 5, color = "black", fontface = "bold")
  }
  
  # Apply style but keep facet labels visible
  p <- p + theme_classic(base_size = 12) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", alpha = 0.8) +
    geom_blank(aes(y = lim_min)) +  # Force minimum
    geom_blank(aes(y = lim_max)) +  # Force maximum
    scale_color_manual(values = network_colors_orig, guide = "none") +
    theme(
      strip.text = element_text(size = 14, face = "bold", color = "black"),
      strip.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
      axis.text.y = element_text(size = 11),
      panel.spacing = unit(1, "lines")
    ) 
  
  return(p)
}

# ---- Prepare forest data for all three contrasts from mega_table ----
forest_data_stim <- prepare_forest_data_from_mega(mega_table, "stimulant_vs_placebo")
forest_data_psy  <- prepare_forest_data_from_mega(mega_table, "psychedelic_vs_placebo")
forest_data_contrast <- prepare_forest_data_from_mega(mega_table, "psychedelic_vs_stimulant")

# ---- Create separate plots ----
# Now sig_stars uses p_holm values from combined table
forest_stim <- plot_forest(forest_data_stim, "Stimulants vs Placebo", sig_stars = TRUE)
forest_psy  <- plot_forest(forest_data_psy, "Psychedelics vs Placebo", sig_stars = TRUE)
forest_contrast <- plot_forest(forest_data_contrast, "Psychedelics vs Stimulants", sig_stars = TRUE)

# Combine all MSE data (now with Holm-corrected significance)
MSE_model_data <- rbind(forest_data_psy, forest_data_stim, forest_data_contrast)
MSE_model_data <- tibble(MSE_model_data)

# ---- Display plots ----
forest_stim
forest_psy
forest_contrast

# Grid arrangement
library(gridExtra)
grid.arrange(forest_psy,forest_stim,
             forest_contrast, 
             ncol = 3)
```


Same plots for the NGSC with correction
```{r}
# ---- Filter and prepare regional NGSC data ----
ngsc_plot_data <- combined_detailed_table %>%
  filter(variable == "NGSC") %>%
  mutate(
    # Map networks to full names
    network_full = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "Limbic" ~ "Limbic",
      network == "DorsAttn" ~ "Dorsal Attention",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Map contrasts to proper drug names
    contrast_clean = case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    ),
    # Type classification
    type = case_when(
      contrast %in% c("PSI", "LSD", "MES", "AMP", "MDMA") ~ "Drug Effect",
      contrast %in% c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    )
  )

# ---- Create desired contrast ordering ----
desired_order <- c(
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",  # Individual drugs
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",  # Within class
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine", 
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"  # Between class
)

ngsc_plot_data$contrast_clean <- factor(ngsc_plot_data$contrast_clean, levels = desired_order)

# ---- Create color mapping - individual drugs get colors, contrasts are black ----
contrast_colors <- c(
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500", 
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black", 
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# ---- Set desired order for networks ----
network_order <- c("Control", "Default Mode", "Dorsal Attention", 
                   "Ventral Attention", "Limbic", "Somatomotor", "Visual")

ngsc_plot_data$network_full <- factor(ngsc_plot_data$network_full, levels = network_order)

# ---- Create the plot ----
ngsc_plot <- ggplot(ngsc_plot_data, aes(x = contrast_clean, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical separating lines
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_point(aes(color = contrast_clean), size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper, color = contrast_clean), 
                width = 0.25, linewidth = 0.8) +
  # Add significance stars based on p_holm
  geom_text(aes(y = upper, label = sig_star), vjust = 0.3, hjust = 0.5,
            size = 4, fontface = "bold", color = "black") +
  scale_color_manual(values = contrast_colors) +
  facet_wrap(~ network_full, scales = "free_y", ncol = 4) +
  labs(y = "Estimate (%)", x = NULL) +
  theme_classic(base_size = 13) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    panel.spacing = unit(1, "lines")
  )

print(ngsc_plot)

# Optional: Save
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/ngsc_detailed.pdf",
#        plot = ngsc_plot, width = 14, height = 8, units = "in")
```


Now for all the regional NGSC
```{r}
# ---- Function to prepare NGSC forest data from mega_table ----
prepare_ngsc_data_from_mega <- function(mega_table, contrast_name) {
  
  # Filter for the specific contrast and NGSC metrics only
  df <- mega_table %>%
    filter(contrast == contrast_name,
           metric_type == "NGSC") %>%
    mutate(
      network = network_1,
      network_clean = case_when(
        network == "Cont" ~ "Control",
        network == "Default" ~ "Default Mode",
        network == "Limbic" ~ "Limbic",
        network == "DorsAttn" ~ "Dorsal Attention", 
        network == "SalVentAttn" ~ "Ventral Attention",
        network == "SomMot" ~ "Somatomotor",
        network == "Vis" ~ "Visual",
        TRUE ~ network
      ),
      sig_star = case_when(
        p_holm < 0.001 ~ "***",
        p_holm < 0.01  ~ "**",
        p_holm < 0.05  ~ "*",
        TRUE            ~ ""
      ),
      network_clean = factor(network_clean, levels = c(
        "Control", "Default Mode", "Dorsal Attention", "Ventral Attention", 
        "Limbic", "Somatomotor", "Visual"
      ))
    )
  
  return(df)
}

# ---- Network colors ----
network_colors <- c(
  "Control" = "#e74c3c",
  "Default Mode" = "#3498db", 
  "Dorsal Attention" = "#2ecc71",
  "Limbic" = "#f39c12",
  "Ventral Attention" = "#9b59b6",
  "Somatomotor" = "#1abc9c",
  "Visual" = "#34495e"
)

# ---- style_forest function (if not already defined) ----
style_forest <- function(p) {
  p +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray40", alpha = 0.8) +
    scale_color_manual(values = network_colors, guide = "none") +
    theme_classic(base_size = 12) +
    theme(
      strip.text = element_text(size = 14, face = "bold", color = "white"),
      strip.background = element_rect(fill = "gray30", color = "white", linewidth = 0.5),
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 30, hjust = 1, size = 11),
      axis.text.y = element_text(size = 11),
      panel.spacing = unit(1, "lines")
    )
}

# ---- Prepare NGSC data for all three contrasts from mega_table ----
forest_data_ngse_stimulants <- prepare_ngsc_data_from_mega(mega_table, "stimulant_vs_placebo")
forest_data_ngse_psychedelics <- prepare_ngsc_data_from_mega(mega_table, "psychedelic_vs_placebo")
forest_data_ngse <- prepare_ngsc_data_from_mega(mega_table, "psychedelic_vs_stimulant")

# ---- Forest plot for Psychedelics vs Stimulants (WITH significance stars) ----
forest_ngse <- ggplot(forest_data_ngse, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16) +
  geom_text(aes(y = upper + 0.0005, label = sig_star),
            size = 5, color = "black", fontface = "bold")

forest_ngse <- style_forest(forest_ngse)
print(forest_ngse)

# ---- Forest plot for Psychedelics vs Placebo (WITH significance stars now) ----
forest_ngse_psychedelics <- ggplot(forest_data_ngse_psychedelics, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16) +
  geom_text(aes(y = upper + 0.0005, label = sig_star),
            size = 5, color = "black", fontface = "bold")

forest_ngse_psychedelics <- style_forest(forest_ngse_psychedelics) + ylim(-0.02, 0.13)
print(forest_ngse_psychedelics)

# ---- Forest plot for Stimulants vs Placebo (WITH significance stars now) ----
forest_ngse_stimulants <- ggplot(forest_data_ngse_stimulants, aes(x = network_clean, y = estimate, color = network_clean)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.25, size = 1) +
  geom_point(size = 4, shape = 16) +
  geom_text(aes(y = upper + 0.0005, label = sig_star),
            size = 5, color = "black", fontface = "bold")

forest_ngse_stimulants <- style_forest(forest_ngse_stimulants) + ylim(-0.02, 0.13)
print(forest_ngse_stimulants)

# ---- Combine into one table for export ----
forest_data_all_ngsc <- bind_rows(
  forest_data_ngse_stimulants %>% mutate(Contrast = "Stimulants vs Placebo"),
  forest_data_ngse_psychedelics %>% mutate(Contrast = "Psychedelics vs Placebo"),
  forest_data_ngse %>% mutate(Contrast = "Psychedelics vs Stimulants")
) %>%
  mutate(
    Contrast = factor(Contrast, levels = c(
      "Stimulants vs Placebo", 
      "Psychedelics vs Placebo", 
      "Psychedelics vs Stimulants"
    ))
  ) %>%
  select(Contrast, network_clean, estimate, lower, upper, p_uncorrected, p_holm, sig_star)

# View the combined dataset
print(forest_data_all_ngsc)

# Export to Excel

#write_xlsx(forest_data_all_ngsc, "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/NGSC_forest_betas.xlsx")

# Grid arrangement

grid.arrange(forest_ngse_psychedelics,forest_ngse_stimulants, forest_ngse, nrow = 3)
```


Now for the DCC entropy 
```{r}
# ---- Function to prepare DCC data from mega_table ----
prepare_dcc_data_from_mega <- function(mega_table, contrast_name) {
  
  # Filter for the specific contrast and DCC metrics only
  df <- mega_table %>%
    filter(contrast == contrast_name,
           metric_type == "DCC") %>%
    select(test_name, contrast, network_1, network_2, 
           estimate, lower, upper, p_uncorrected, p_holm)
  
  return(df)
}

# Extract DCC data for all three contrasts
dcc_contrast <- prepare_dcc_data_from_mega(mega_table, "psychedelic_vs_stimulant")
dcc_psychedelics <- prepare_dcc_data_from_mega(mega_table, "psychedelic_vs_placebo")
dcc_stimulants <- prepare_dcc_data_from_mega(mega_table, "stimulant_vs_placebo")

# Define the network labels and order (shortened for better readability)
network_labels <- c("Cont" = "CON",
                   "Default" = "DMN", 
                   "DorsAttn" = "DAN",
                   "SalVentAttn" = "VAN",
                   "Limbic" = "LIM",
                   "SomMot" = "SMN",
                   "Vis" = "VIS")
network_order <- names(network_labels)

# Function to add significance stars based on Holm-corrected p-values
add_stars <- function(p_values) {
  stars <- case_when(
    p_values < 0.001 ~ "***",
    p_values < 0.01 ~ "**", 
    p_values < 0.05 ~ "*",
    TRUE ~ ""
  )
  return(stars)
}

# Function to process data for plotting
process_data <- function(df, show_stars = TRUE) {
  
  df_processed <- df %>%
    mutate(
      # Add significance stars using p_holm
      stars = add_stars(p_holm),
      
      # Use network_1 and network_2 from mega_table
      network1_raw = network_1,
      network2_raw = network_2,
      
      # Ensure consistent ordering for network pairs
      network1_idx = match(network1_raw, network_order),
      network2_idx = match(network2_raw, network_order),
      
      # For lower triangle: put the network with higher index as network1 (y-axis)
      # and the one with lower index as network2 (x-axis)
      network1 = ifelse(network1_idx >= network2_idx, network1_raw, network2_raw),
      network2 = ifelse(network1_idx >= network2_idx, network2_raw, network1_raw),
      
      # Create display text with conditional significance stars
      display_text = case_when(
        show_stars & abs(estimate) < 0.001 ~ paste0("<0.001", stars),
        show_stars ~ paste0(sprintf("%.3f", estimate), stars),
        abs(estimate) < 0.001 ~ "<0.001",
        TRUE ~ sprintf("%.3f", estimate)
      ),
      est_rounded = round(estimate, 3)
    ) %>%
    select(-network1_raw, -network2_raw, -network1_idx, -network2_idx)
  
  # Filter for lower triangle only
  df_lower <- df_processed %>%
    mutate(
      net1_idx = match(network1, network_order),
      net2_idx = match(network2, network_order)
    ) %>%
    filter(net1_idx >= net2_idx) %>%
    select(-net1_idx, -net2_idx)
  
  return(df_lower)
}

# Function to create publication-quality plot
create_plot <- function(df_lower, panel_label, fill_label) {
  p <- ggplot(df_lower, aes(x = network2, y = network1, fill = estimate)) +
    geom_tile(color = "white", linewidth = 0.8) +
    geom_text(aes(label = display_text), 
              color = "black", 
              size = 4.8, 
              fontface = "bold",
              family = "Arial") +
    scale_fill_gradient2(
      low = "#053061", 
      mid = "white", 
      high = "#67001F",
      midpoint = 0,
      name = fill_label,
      limits = c(-max_abs, max_abs),  # Consistent scale across plots
      breaks = scales::pretty_breaks(n = 5),
      labels = function(x) sprintf("%.3f", x),
      guide = guide_colorbar(
        title.position = "top",
        title.hjust = 0.5,
        barwidth = 0.8,
        barheight = 6,
        frame.colour = "black",
        frame.linewidth = 0.5
      )
    ) +
    scale_x_discrete(limits = network_order, labels = network_labels, position = "bottom") +
    scale_y_discrete(limits = rev(network_order), labels = network_labels) +
    labs(x = "", y = "", tag = panel_label) +
    theme_minimal(base_family = "Arial", base_size = 10) +
    theme(
      # Axes - no angle, bigger text
      axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 11, color = "black"),
      axis.text.y = element_text(hjust = 1, size = 11, color = "black"),
      
      # Legend
      legend.title = element_text(size = 9, face = "bold"),
      legend.text = element_text(size = 8),
      legend.position = "right",
      legend.margin = margin(l = 10),
      
      # Panel
      panel.grid = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      
      # Plot tag (panel label)
      plot.tag = element_text(size = 12, face = "bold", hjust = 0, vjust = 1),
      plot.tag.position = c(0.02, 0.98),
      
      # Margins
      plot.margin = margin(5, 5, 5, 5, "mm")
    ) +
    coord_fixed(expand = FALSE)
  
  return(p)
}

# Process data for all three conditions
df_contrast <- process_data(dcc_contrast, show_stars = TRUE)
df_psychedelics <- process_data(dcc_psychedelics, show_stars = TRUE)
df_stimulants <- process_data(dcc_stimulants, show_stars = TRUE)

# Calculate global range for consistent color scaling across ALL plots
df_all_data <- bind_rows(
  df_contrast %>% mutate(condition = "contrast"),
  df_psychedelics %>% mutate(condition = "psychedelics"), 
  df_stimulants %>% mutate(condition = "stimulants")
)
global_range <- range(df_all_data$estimate, na.rm = TRUE)
max_abs <- max(abs(global_range))

# Print the range for verification
cat("Global estimate range:", round(global_range, 4), "\n")
cat("Using symmetric scale from", round(-max_abs, 4), "to", round(max_abs, 4), "\n")

# Create publication-quality plots
p1 <- create_plot(df_contrast, "", "Difference\n(Psy − Stim)")
p2 <- create_plot(df_psychedelics, "", "Psychedelics")
p3 <- create_plot(df_stimulants, "", "Stimulants")

# Display plots
print(p1)
print(p2)
print(p3)

# # Save individual plots
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_contrast.pdf", 
#         plot = p1, device = cairo_pdf, width = 10, height = 6, units = "in")
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_psychedelics.pdf", 
#        plot = p2, device = cairo_pdf, width = 10, height = 6, units = "in")  
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/DCC_heatmap_stimulants.pdf", 
#        plot = p3, device = cairo_pdf, width = 10, height = 6, units = "in")
```

DCC circle diagrams
```{r}
# Network colors for the outer ring
network_colors <- c(
  "Cont" = "#E31A1C",           # Red
  "Default" = "#1F78B4",        # Blue  
  "DorsAttn" = "#33A02C",       # Green
  "Limbic" = "#FF7F00",         # Orange
  "SalVentAttn" = "#6A3D9A",    # Purple
  "SomMot" = "#A6CEE3",         # Light blue
  "Vis" = "#FDBF6F"             # Light orange
)

# Network name mapping from abbreviations to full names
network_name_map <- c(
  "Cont" = "CON",
  "Default" = "DMN", 
  "DorsAttn" = "DAN",
  "Limbic" = "LIM",
  "SalVentAttn" = "VAN",
  "SomMot" = "SMN",
  "Vis" = "VIS"
)

# Define network order for consistent positioning
network_order <- c("Vis", "SomMot", "DorsAttn", "SalVentAttn", "Limbic", "Cont", "Default")

# Create the chord diagram with gradient coloring
create_connectivity_plot <- function(data, plot_title = NULL) {
  
  # Check for required columns
  if (!"p_value" %in% colnames(data) && !"p_holm" %in% colnames(data)) {
    stop("p_value or p_holm column not found in data!")
  }
  if (!"est_rounded" %in% colnames(data)) {
    stop("est_rounded column not found in data!")
  }
  
  # Use p_holm if available, otherwise p_value
  if ("p_holm" %in% colnames(data)) {
    data$p_value <- data$p_holm
  }
  
  # Remove bidirectional duplicates
  data_with_pairs <- data %>%
    mutate(
      net_min = pmin(network1, network2),
      net_max = pmax(network1, network2),
      pair_id = paste(net_min, net_max, sep = "-"),
      is_self = (network1 == network2)
    )
  
  data_clean <- data_with_pairs %>%
    group_by(pair_id) %>%
    slice(1) %>%
    ungroup() %>%
    select(-net_min, -net_max, -pair_id)
  
  cat("\n=== Data Processing ===\n")
  cat("Original connections:", nrow(data), "\n")
  cat("After removing bidirectional duplicates:", nrow(data_clean), "\n")
  
  # Separate self vs between-network connections
  self_connections <- data_clean %>% filter(network1 == network2)
  between_connections <- data_clean %>% filter(network1 != network2)
  
  cat("Self-connections:", nrow(self_connections), "\n")
  cat("Between-network connections:", nrow(between_connections), "\n")
  
  # Count significant connections
  alpha_threshold <- 0.05
  n_significant <- sum(data_clean$p_value <= alpha_threshold)
  n_total <- nrow(data_clean)
  
  cat("\n=== Significance Summary (Holm-Corrected) ===\n")
  cat("Total unique connections:", n_total, "\n")
  cat("Significant connections (p_holm ≤", alpha_threshold, "):", n_significant, "\n")
  cat("Non-significant connections:", n_total - n_significant, "\n")
  cat("Percentage significant:", round(100 * n_significant / n_total, 1), "%\n")
  
  # Effect size summary
  sig_data <- data_clean %>% filter(p_value <= alpha_threshold)
  if (nrow(sig_data) > 0) {
    cat("\n=== Effect Size Summary (Significant Only) ===\n")
    cat("Range: [", round(min(sig_data$est_rounded), 3), ",", 
        round(max(sig_data$est_rounded), 3), "]\n")
    cat("Mean:", round(mean(sig_data$est_rounded), 3), "\n")
    cat("Median:", round(median(sig_data$est_rounded), 3), "\n")
    
    pos_sig <- sum(sig_data$est_rounded > 0)
    neg_sig <- sum(sig_data$est_rounded < 0)
    cat("\nPositive effects:", pos_sig, 
        "(", round(100 * pos_sig / nrow(sig_data), 1), "%)\n")
    cat("Negative effects:", neg_sig, 
        "(", round(100 * neg_sig / nrow(sig_data), 1), "%)\n")
    
    cat("\n=== Top 10 Strongest Connections ===\n")
    top_connections <- sig_data %>% 
      arrange(desc(abs(est_rounded))) %>% 
      head(10)
    
    for(i in 1:nrow(top_connections)) {
      connection_type <- ifelse(top_connections$network1[i] == top_connections$network2[i], 
                                "within", "between")
      direction <- ifelse(top_connections$est_rounded[i] > 0, "↑", "↓")
      cat(sprintf("  %s %s ↔ %s: %.3f (p_holm = %.4f) [%s]\n", 
                  direction,
                  top_connections$network1[i], 
                  top_connections$network2[i], 
                  top_connections$est_rounded[i], 
                  top_connections$p_value[i], 
                  connection_type))
    }
  }
  
  # Prepare all edges with gradient coloring 
  chord_data <- data_clean %>%
    mutate(
      abs_beta = abs(est_rounded),
      beta_norm = (abs_beta - min(abs_beta)) / (max(abs_beta) - min(abs_beta)),
      base_color = ifelse(est_rounded > 0, "#67001F", "#053061"),  # Dark red for positive, dark blue for negative
      alpha = beta_norm^2 * 0.85 + 0.15  # Very close to original, just slightly more visible
    ) %>%
    arrange(desc(abs_beta))
  
  # Print value range for debugging
  cat("\nValue range in data:\n")
  cat("Min:", min(chord_data$est_rounded), "\n")
  cat("Max:", max(chord_data$est_rounded), "\n")
  cat("Mean:", mean(abs(chord_data$est_rounded)), "\n")
  
  # Create color vector with alpha
  edge_colors <- sapply(1:nrow(chord_data), function(i) {
    alpha(chord_data$base_color[i], chord_data$alpha[i])
  })
  
  # Set factor levels for ordering - THIS WAS MISSING!
  chord_data$network1 <- factor(chord_data$network1, levels = network_order)
  chord_data$network2 <- factor(chord_data$network2, levels = network_order)
  
  # Clear any previous plots
  circos.clear()
  
  # Set parameters
  circos.par(
    start.degree = 90, 
    gap.degree = 4
  )
  
  # Create chord diagram - use small constant value for thin chords
  # The value controls thickness; use a small constant to make all chords thin
  chord_data_for_plot <- chord_data
  chord_data_for_plot$const_val <- 0.001  # Very small constant for thin chords
  
  chordDiagram(
    chord_data_for_plot[, c("network1", "network2", "const_val")],
    order = network_order,
    col = edge_colors,
    grid.col = network_colors,
    directional = 0,
    annotationTrack = "grid",
    preAllocateTracks = list(track.height = 0.1)
  )
  
  # Add network labels with full names
  circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    # Map abbreviation to full name
    full_name <- network_name_map[sector.name]
    if(is.na(full_name)) full_name <- sector.name
    
    circos.text(mean(xlim), ylim[1], full_name,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),
                col = "black", font = 2, cex = 1.2)
  }, bg.border = NA)
  
  # Add title if provided
  if (!is.null(plot_title)) {
    title(main = plot_title, cex.main = 1.3, line = 1)
  }
  
  circos.clear()
}



# # Dataset 1: Psychedelics vs Stimulants
# png("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/psychedelics_vs_stimulants_chord.png", 
#     width = 2000, height = 2000, res = 300)
# par(mar = c(1, 1, 3, 1))
# create_connectivity_plot(df_contrast, "Psychedelics vs. Stimulants")
# dev.off()
# cat("\n✓ Created: psychedelics_vs_stimulants_chord.png\n")
# 
# # Dataset 2: Psychedelics vs Placebo
# png("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/psychedelics_connectivity_chord.png", 
#     width = 2000, height = 2000, res = 300)
# par(mar = c(1, 1, 3, 1))
# create_connectivity_plot(df_psychedelics, "Psychedelics vs. Placebo")
# dev.off()
# cat("\n✓ Created: psychedelics_connectivity_chord.png\n")
# 
# # Dataset 3: Stimulants vs Placebo
# png("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/stimulants_vs_placebo_chord.png", 
#     width = 2000, height = 2000, res = 300)
# par(mar = c(1, 1, 3, 1))
# create_connectivity_plot(df_stimulants, "Stimulants vs. Placebo")
# dev.off()
# cat("\n✓ Created: stimulants_vs_placebo_chord.png\n")
```


DCC entropy contrasts
```{r}
# ---- Convert results_DCC list to dataframe ----
dcc_within <- map_dfr(names(results_DCC), function(network_pair) {
  results_DCC[[network_pair]] %>%
    rownames_to_column("rowname") %>%
    mutate(
      network_pair = network_pair,
      contrast = str_extract(rowname, "^[^.]+")
    ) %>%
    select(-rowname)
})

# ---- Convert pairwise_results_DCC list to dataframe ----
dcc_between <- map_dfr(names(pairwise_results_DCC), function(network_pair) {
  pairwise_results_DCC[[network_pair]] %>%
    rownames_to_column("rowname") %>%
    mutate(
      network_pair = network_pair,
      contrast = str_extract(rowname, "^[^.]+")
    ) %>%
    select(-rowname)
})

# ---- Combine DCC data ----
dcc_all <- bind_rows(dcc_within, dcc_between)

# ---- Split network_pair into network and network_2 ----
dcc_all <- dcc_all %>%
  separate(network_pair, into = c("network", "network_2"), sep = "_", extra = "merge") %>%
  mutate(
    variable = "DCC",
    scale = NA
  ) %>%
  select(variable, contrast, network, network_2, scale, estimate, se, df, lower, upper, p.value)

# ---- Combine with existing table ----
combined_detailed_table <- bind_rows(combined_detailed_table, dcc_all)

# View
print(table(combined_detailed_table$variable)) 


# ---- Check number of tests per contrast ----
test_counts <- combined_detailed_table %>%
  group_by(contrast) %>%
  summarise(n_tests = n()) %>%
  arrange(desc(n_tests))

print(test_counts)


# ---- Apply Holm correction within each contrast (53 tests per contrast) ----
combined_detailed_table <- combined_detailed_table %>%
  group_by(contrast) %>%
  mutate(
    p_holm = p.adjust(p.value, method = "holm"),
    sig_star = case_when(
      p_holm < 0.001 ~ "***",
      p_holm < 0.01  ~ "**",
      p_holm < 0.05  ~ "*",
      TRUE ~ ""
    )
  ) %>%
  ungroup()

# ---- Verify ----
print("Tests per contrast (should all be 53):")
combined_detailed_table %>%
  count(contrast) %>%
  print()

cat("\nSignificant results per contrast:\n")
combined_detailed_table %>%
  group_by(contrast) %>%
  summarise(
    n_sig = sum(p_holm < 0.05),
    n_total = n()
  ) %>%
  print()

```

Now redo the MSSE plot with signicance stars based on the new table and the holm correction
```{r}
# ---- Filter and prepare MSSE data ----
msse_plot_data <- combined_detailed_table %>%
  filter(variable == "MSSE") %>%
  mutate(
    # Map networks to full names
    network_full = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "Limbic" ~ "Limbic",
      network == "DorsAttn" ~ "Dorsal Attention",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Map contrasts to proper drug names
    contrast_clean = case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    ),
    # Type classification
    type = case_when(
      contrast %in% c("PSI", "LSD", "MES", "AMP", "MDMA") ~ "Drug Effect",
      contrast %in% c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    ),
    # Scale label
    scale_label = paste0("Scale ", scale)
  )

# ---- Create desired contrast ordering ----
desired_order <- c(
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",  # Individual drugs
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",  # Within class
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine", 
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"  # Between class
)

msse_plot_data$contrast_clean <- factor(msse_plot_data$contrast_clean, levels = desired_order)

# ---- Create color mapping - individual drugs get colors, contrasts are black ----
contrast_colors <- c(
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500", 
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black", 
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# ---- Set desired order for networks ----
network_order <- c("Control", "Default Mode", "Dorsal Attention", 
                   "Ventral Attention", "Limbic", "Somatomotor", "Visual")

msse_plot_data$network_full <- factor(msse_plot_data$network_full, levels = network_order)

# ---- Create the plot ----
msse_plot <- ggplot(msse_plot_data, aes(x = contrast_clean, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical separating lines
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_point(aes(color = contrast_clean), size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper, color = contrast_clean), 
                width = 0.25, linewidth = 0.8) +
  # Add significance stars based on p_holm
  geom_text(aes(y = upper, label = sig_star), vjust = 0.3, hjust = 0.5,
            size = 4, fontface = "bold", color = "black") +
  scale_color_manual(values = contrast_colors) +
  facet_grid(network_full ~ scale_label, scales = "free_y", switch = "y") +
  labs(y = "Estimate (%)", x = NULL) +
  theme_classic(base_size = 13) +
  scale_y_continuous(expand = expansion(mult = c(0.15, 0.10))) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    strip.placement = "outside",
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    panel.spacing = unit(1, "lines")
  )

print(msse_plot)

# Optional: Save
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/msse_detailed.pdf",
#        plot = msse_plot, width = 14, height = 10, units = "in")
```


NGSC with Holm-correction
```{r}
library(tidyverse)

# ---- Filter and prepare regional NGSC data ----
ngsc_plot_data <- combined_detailed_table %>%
  filter(variable == "NGSC") %>%
  mutate(
    # Map networks to full names
    network_full = case_when(
      network == "Cont" ~ "Control",
      network == "Default" ~ "Default Mode",
      network == "Limbic" ~ "Limbic",
      network == "DorsAttn" ~ "Dorsal Attention",
      network == "SalVentAttn" ~ "Ventral Attention",
      network == "SomMot" ~ "Somatomotor",
      network == "Vis" ~ "Visual",
      TRUE ~ network
    ),
    # Map contrasts to proper drug names
    contrast_clean = case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    ),
    # Type classification
    type = case_when(
      contrast %in% c("PSI", "LSD", "MES", "AMP", "MDMA") ~ "Drug Effect",
      contrast %in% c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP") ~ "Within Drug Class",
      TRUE ~ "Between Drug Class"
    )
  )

# ---- Create desired contrast ordering ----
desired_order <- c(
  "Psilocybin", "LSD", "Mescaline", "d-Amphetamine", "MDMA",  # Individual drugs
  "LSD vs Psilocybin", "LSD vs Mescaline", "Mescaline vs Psilocybin", "MDMA vs d-Amphetamine",  # Within class
  "Psilocybin vs d-Amphetamine", "LSD vs d-Amphetamine", "Mescaline vs d-Amphetamine", 
  "Psilocybin vs MDMA", "LSD vs MDMA", "Mescaline vs MDMA"  # Between class
)

ngsc_plot_data$contrast_clean <- factor(ngsc_plot_data$contrast_clean, levels = desired_order)

# ---- Create color mapping - individual drugs get colors, contrasts are black ----
contrast_colors <- c(
  "Psilocybin" = "#ffd700",
  "LSD" = "#ffff00",
  "Mescaline" = "#ffa500", 
  "d-Amphetamine" = "#8b0000",
  "MDMA" = "#b22222",
  "LSD vs Psilocybin" = "black",
  "LSD vs Mescaline" = "black",
  "Mescaline vs Psilocybin" = "black",
  "MDMA vs d-Amphetamine" = "black",
  "Psilocybin vs d-Amphetamine" = "black",
  "LSD vs d-Amphetamine" = "black", 
  "Mescaline vs d-Amphetamine" = "black",
  "Psilocybin vs MDMA" = "black",
  "LSD vs MDMA" = "black",
  "Mescaline vs MDMA" = "black"
)

# ---- Set desired order for networks ----
network_order <- c("Control", "Default Mode", "Dorsal Attention", 
                   "Ventral Attention", "Limbic", "Somatomotor", "Visual")

ngsc_plot_data$network_full <- factor(ngsc_plot_data$network_full, levels = network_order)

# ---- Create the plot ----
ngsc_plot <- ggplot(ngsc_plot_data, aes(x = contrast_clean, y = estimate)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # Add vertical separating lines
  geom_vline(xintercept = 5.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_vline(xintercept = 9.5, linetype = "solid", color = "grey30", linewidth = 0.5) +  
  geom_point(aes(color = contrast_clean), size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper, color = contrast_clean), 
                width = 0.25, linewidth = 0.8) +
  # Add significance stars based on p_holm
  geom_text(aes(y = upper, label = sig_star), vjust = -0.3, hjust = 0.5,
            size = 4, fontface = "bold", color = "black") +
  scale_color_manual(values = contrast_colors) +
  facet_wrap(~ network_full, scales = "free_y", ncol = 2) +
  labs(y = "Estimate (%)", x = NULL) +
  theme_classic(base_size = 13) +
    scale_y_continuous(expand = expansion(mult = c(0.15, 0.10))) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    axis.text.x = element_text(angle = 65, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    legend.position = "none",
    panel.spacing = unit(1, "lines")
  )

print(ngsc_plot)

# Optional: Save
# ggsave("/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/ngsc_detailed.pdf",
#        plot = ngsc_plot, width = 14, height = 8, units = "in")
```


Now for the DCC Heatmaps with Holm-correction
```{r}
# Define the network labels and order
network_labels <- c("Cont" = "CON",
                   "Default" = "DMN", 
                   "DorsAttn" = "DAN",
                   "SalVentAttn" = "VAN",
                   "Limbic" = "LIM",
                   "SomMot" = "SMN",
                   "Vis" = "VIS")
network_order <- names(network_labels)

# Function to add significance stars based on Holm-corrected p-values
add_stars <- function(p_values) {
  case_when(
    p_values < 0.001 ~ "***",
    p_values < 0.01 ~ "**", 
    p_values < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Function to process DCC data from combined_detailed_table for plotting
process_dcc_data_from_table <- function(combined_detailed_table, contrast_name, show_stars = TRUE) {
  
  # Filter for DCC data and the specific contrast
  df <- combined_detailed_table %>%
    filter(variable == "DCC", contrast == contrast_name) %>%
    mutate(
      # Create network combination
      network_combo = paste0(network, "_", network_2),
      
      # Add significance stars using p_holm
      stars = add_stars(p_holm),
      
      # Split into network1 and network2
      network1_raw = network,
      network2_raw = network_2,
      
      # Ensure consistent ordering for network pairs
      network1_idx = match(network1_raw, network_order),
      network2_idx = match(network2_raw, network_order),
      
      # For lower triangle: put the network with higher index as network1 (y-axis)
      # and the one with lower index as network2 (x-axis)
      network1 = ifelse(network1_idx >= network2_idx, network1_raw, network2_raw),
      network2 = ifelse(network1_idx >= network2_idx, network2_raw, network1_raw),
      
      # Create display text with conditional significance stars
      display_text = case_when(
        show_stars & abs(estimate) < 0.01 ~ paste0("<0.01%", stars),
        show_stars ~ paste0(sprintf("%.2f%%", estimate), stars),
        abs(estimate) < 0.01 ~ "<0.01%",
        TRUE ~ sprintf("%.2f%%", estimate)
      ),
      est_rounded = round(estimate, 2)
    )
  
  # Filter for lower triangle only (including diagonal)
  df_lower <- df %>%
    mutate(
      net1_idx = match(network1, network_order),
      net2_idx = match(network2, network_order)
    ) %>%
    filter(net1_idx >= net2_idx) %>%
    select(-net1_idx, -net2_idx, -network1_raw, -network2_raw, -network1_idx, -network2_idx)
  
  return(df_lower)
}

# Function to create DCC heatmap plot
create_dcc_plot <- function(df_lower, panel_label, fill_label, max_abs = NULL) {
  
  # Calculate max absolute value for consistent scaling if not provided
  if (is.null(max_abs)) {
    max_abs <- max(abs(df_lower$estimate), na.rm = TRUE)
  }
  
  p <- ggplot(df_lower, aes(x = network2, y = network1, fill = estimate)) +
    geom_tile(color = "white", linewidth = 0.8) +
    geom_text(aes(label = display_text), 
              color = "black", 
              size = 4.8, 
              fontface = "bold",
              family = "Arial") +
    scale_fill_gradient2(
      low = "#053061", 
      mid = "white", 
      high = "#67001F",
      midpoint = 0,
      name = fill_label,
      limits = c(-max_abs, max_abs),
      breaks = scales::pretty_breaks(n = 5),
      labels = function(x) sprintf("%.2f", x),
      guide = guide_colorbar(
        title.position = "top",
        title.hjust = 0.5,
        barwidth = 0.8,
        barheight = 6,
        frame.colour = "black",
        frame.linewidth = 0.5
      )
    ) +
    scale_x_discrete(limits = network_order, labels = network_labels, position = "bottom") +
    scale_y_discrete(limits = rev(network_order), labels = network_labels) +
    labs(x = "", y = "", tag = panel_label) +
    theme_minimal(base_family = "Arial", base_size = 10) +
    theme(
      # Axes - no angle, bigger text
      axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 11, color = "black"),
      axis.text.y = element_text(hjust = 1, size = 11, color = "black"),
      
      # Legend
      legend.title = element_text(size = 9, face = "bold"),
      legend.text = element_text(size = 8),
      legend.position = "right",
      legend.margin = margin(l = 10),
      
      # Panel
      panel.grid = element_blank(),
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      
      # Plot tag (panel label)
      plot.tag = element_text(size = 12, face = "bold", hjust = 0, vjust = 1),
      plot.tag.position = c(0.02, 0.98),
      
      # Margins
      plot.margin = margin(5, 5, 5, 5, "mm")
    ) +
    coord_fixed(expand = FALSE)
  
  return(p)
}

# Function to create multiple DCC heatmaps for different contrasts
create_multiple_dcc_heatmaps <- function(combined_detailed_table, contrasts_to_plot = NULL, 
                                       consistent_scale = TRUE, show_stars = TRUE) {
  
  # Get available contrasts if not specified
  if (is.null(contrasts_to_plot)) {
    contrasts_to_plot <- combined_detailed_table %>%
      filter(variable == "DCC") %>%
      pull(contrast) %>%
      unique()
  }
  
  # Calculate global max for consistent scaling
  if (consistent_scale) {
    global_max <- combined_detailed_table %>%
      filter(variable == "DCC", contrast %in% contrasts_to_plot) %>%
      pull(estimate) %>%
      abs() %>%
      max(na.rm = TRUE)
  } else {
    global_max <- NULL
  }
  
  # Create list to store plots
  plots <- list()
  
  # Generate plot for each contrast
  for (i in seq_along(contrasts_to_plot)) {
    contrast <- contrasts_to_plot[i]
    
    # Process data for this contrast
    df_lower <- process_dcc_data_from_table(
      combined_detailed_table, 
      contrast, 
      show_stars = show_stars
    )
    
    # Skip if no data
    if (nrow(df_lower) == 0) {
      warning(paste("No data found for contrast:", contrast))
      next
    }
    
    # Create panel label
    panel_label <- LETTERS[i]
    
    # Clean contrast name for title
    clean_contrast <- case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    )
    
    # Create plot
    if (consistent_scale) {
      plot_max <- global_max
    } else {
      plot_max <- max(abs(df_lower$estimate), na.rm = TRUE)
    }
    
    p <- create_dcc_plot(
      df_lower, 
      panel_label, 
      "Estimate (%)",
      max_abs = plot_max
    ) +
      ggtitle(clean_contrast)
    
    plots[[contrast]] <- p
  }
  
  return(plots)
}

# Convenience function to plot contrasts by type
plot_contrasts_by_type <- function(combined_detailed_table, contrast_type = "all") {
  
  # Get all available contrasts
  all_contrasts <- combined_detailed_table %>%
    filter(variable == "DCC") %>%
    pull(contrast) %>%
    unique()
  
  # Filter contrasts by type
  if (contrast_type == "individual") {
    contrasts <- c("PSI", "LSD", "MES", "AMP", "MDMA")
  } else if (contrast_type == "within") {
    contrasts <- c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP")
  } else if (contrast_type == "between") {
    contrasts <- c("PSI_vs_AMP", "LSD_vs_AMP", "MES_vs_AMP", 
                   "PSI_vs_MDA", "LSD_vs_MDA", "MES_vs_MDA")
  } else {
    contrasts <- all_contrasts
  }
  
  # Filter to only existing contrasts
  contrasts <- contrasts[contrasts %in% all_contrasts]
  
  return(create_multiple_dcc_heatmaps(combined_detailed_table, contrasts))
}

# Function to save all DCC plots as PDFs
save_dcc_plots_as_pdf <- function(plot_list, base_path, width = 8, height = 6) {
  
  # Create directory if it doesn't exist
  dir.create(dirname(base_path), recursive = TRUE, showWarnings = FALSE)
  
  # Loop through each plot and save
  for (contrast_name in names(plot_list)) {
    # Clean the contrast name for filename (remove special characters)
    clean_name <- gsub("[^A-Za-z0-9_]", "_", contrast_name)
    clean_name <- gsub("_{2,}", "_", clean_name)  # Replace multiple underscores with single
    clean_name <- gsub("_$", "", clean_name)     # Remove trailing underscore
    
    # Create full filepath
    filepath <- file.path(dirname(base_path), 
                         paste0("DCC_heatmap_", clean_name, ".pdf"))
    
    # Save plot
    ggsave(filepath, 
           plot = plot_list[[contrast_name]], 
           device = cairo_pdf, 
           width = width, 
           height = height, 
           units = "in")
    
    cat("Saved:", filepath, "\n")
  }
}

# ---- Usage ----

# Plot all individual drug contrasts
individual_plots <- plot_contrasts_by_type(combined_detailed_table, "individual")

# Plot within-class comparisons
within_plots <- plot_contrasts_by_type(combined_detailed_table, "within")

# Plot between-class comparisons
between_plots <- plot_contrasts_by_type(combined_detailed_table, "between")

# Plot all contrasts
all_plots <- create_multiple_dcc_heatmaps(combined_detailed_table)

# Display a specific plot
print(individual_plots[["PSI"]])

# Save all plots
base_path <- "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/"
save_dcc_plots_as_pdf(all_plots, base_path)
```

DCC circles with Holm-corrrection
```{r}
library(tidyverse)
library(circlize)
library(scales)

# Network colors for the outer ring
network_colors <- c(
  "Cont" = "#E31A1C",           # Red
  "Default" = "#1F78B4",        # Blue  
  "DorsAttn" = "#33A02C",       # Green
  "Limbic" = "#FF7F00",         # Orange
  "SalVentAttn" = "#6A3D9A",    # Purple
  "SomMot" = "#A6CEE3",         # Light blue
  "Vis" = "#FDBF6F"             # Light orange
)

# Network name mapping
network_name_map <- c(
  "Cont" = "CON",
  "Default" = "DMN", 
  "DorsAttn" = "DAN",
  "Limbic" = "LIM",
  "SalVentAttn" = "VAN",
  "SomMot" = "SMN",
  "Vis" = "VIS"
)

# Define network order for consistent positioning
network_order <- c("Vis", "SomMot", "DorsAttn", "SalVentAttn", "Limbic", "Cont", "Default")

# Function to prepare DCC data for chord diagram from combined_detailed_table
prepare_dcc_chord_data <- function(combined_detailed_table, contrast_name) {
  
  # Filter for DCC data and specific contrast
  df <- combined_detailed_table %>%
    filter(variable == "DCC", contrast == contrast_name) %>%
    mutate(
      network1 = network,
      network2 = network_2,
      est_rounded = round(estimate, 3),
      p_value = p_holm  # Use Holm-corrected p-values
    ) %>%
    select(network1, network2, estimate, p_value, est_rounded)
  
  return(df)
}

# Main function to create chord diagram for DCC data
create_dcc_chord_diagram <- function(combined_detailed_table, contrast_name, 
                                   plot_title = NULL, alpha = 0.05) {
  
  # Prepare data
  data <- prepare_dcc_chord_data(combined_detailed_table, contrast_name)
  
  if (nrow(data) == 0) {
    warning(paste("No data found for contrast:", contrast_name))
    return(NULL)
  }
  
  # Create plot title if not provided
  if (is.null(plot_title)) {
    plot_title <- case_when(
      contrast_name == "PSI" ~ "Psilocybin",
      contrast_name == "LSD" ~ "LSD",
      contrast_name == "MES" ~ "Mescaline",
      contrast_name == "AMP" ~ "d-Amphetamine",
      contrast_name == "MDMA" ~ "MDMA",
      contrast_name == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast_name == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast_name == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast_name == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast_name == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast_name == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast_name == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast_name == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast_name == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast_name == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast_name
    )
  }
  
  # Remove bidirectional duplicates
  data_with_pairs <- data %>%
    mutate(
      net_min = pmin(network1, network2),
      net_max = pmax(network1, network2),
      pair_id = paste(net_min, net_max, sep = "-"),
      is_self = (network1 == network2)
    )
  
  data_clean <- data_with_pairs %>%
    group_by(pair_id) %>%
    slice(1) %>%
    ungroup() %>%
    select(-net_min, -net_max, -pair_id)
  
  cat("\n=== Data Processing ===\n")
  cat("Processing contrast:", contrast_name, "\n")
  cat("Original connections:", nrow(data), "\n")
  cat("After removing bidirectional duplicates:", nrow(data_clean), "\n")
  
  # Separate self vs between-network connections
  self_connections <- data_clean %>% filter(network1 == network2)
  between_connections <- data_clean %>% filter(network1 != network2)
  
  cat("Self-connections:", nrow(self_connections), "\n")
  cat("Between-network connections:", nrow(between_connections), "\n")
  
  # Count significant connections (using Holm-corrected p-values)
  n_significant <- sum(data_clean$p_value <= alpha)
  n_total <- nrow(data_clean)
  
  cat("\n=== Significance Summary (Holm-Corrected) ===\n")
  cat("Total unique connections:", n_total, "\n")
  cat("Significant connections (p_holm ≤", alpha, "):", n_significant, "\n")
  cat("Non-significant connections:", n_total - n_significant, "\n")
  cat("Percentage significant:", round(100 * n_significant / n_total, 1), "%\n")
  
  # Effect size summary
  sig_data <- data_clean %>% filter(p_value <= alpha)
  if (nrow(sig_data) > 0) {
    cat("\n=== Effect Size Summary (Significant Only) ===\n")
    cat("Range: [", round(min(sig_data$est_rounded), 3), ",", 
        round(max(sig_data$est_rounded), 3), "]\n")
    cat("Mean:", round(mean(sig_data$est_rounded), 3), "\n")
    cat("Median:", round(median(sig_data$est_rounded), 3), "\n")
    
    pos_sig <- sum(sig_data$est_rounded > 0)
    neg_sig <- sum(sig_data$est_rounded < 0)
    cat("\nPositive effects:", pos_sig, 
        "(", round(100 * pos_sig / nrow(sig_data), 1), "%)\n")
    cat("Negative effects:", neg_sig, 
        "(", round(100 * neg_sig / nrow(sig_data), 1), "%)\n")
    
    cat("\n=== Top 10 Strongest Connections ===\n")
    top_connections <- sig_data %>% 
      arrange(desc(abs(est_rounded))) %>% 
      head(10)
    
    for(i in 1:nrow(top_connections)) {
      connection_type <- ifelse(top_connections$network1[i] == top_connections$network2[i], 
                                "within", "between")
      direction <- ifelse(top_connections$est_rounded[i] > 0, "↑", "↓")
      cat(sprintf("  %s %s ↔ %s: %.3f (p_holm = %.4f) [%s]\n", 
                  direction,
                  top_connections$network1[i], 
                  top_connections$network2[i], 
                  top_connections$est_rounded[i], 
                  top_connections$p_value[i], 
                  connection_type))
    }
  }
  
  # Prepare all edges with gradient coloring
  chord_data <- data_clean %>%
    mutate(
      abs_beta = abs(est_rounded),
      beta_norm = (abs_beta - min(abs_beta)) / (max(abs_beta) - min(abs_beta)),
      base_color = ifelse(est_rounded > 0, "#67001F", "#053061"),  # Dark red for positive, dark blue for negative
      alpha = beta_norm^2 * 0.85 + 0.15
    ) %>%
    arrange(desc(abs_beta))
  
  # Print value range for debugging
  cat("\nValue range in data:\n")
  cat("Min:", min(chord_data$est_rounded), "\n")
  cat("Max:", max(chord_data$est_rounded), "\n")
  cat("Mean:", mean(abs(chord_data$est_rounded)), "\n")
  
  # Create color vector with alpha
  edge_colors <- sapply(1:nrow(chord_data), function(i) {
    alpha(chord_data$base_color[i], chord_data$alpha[i])
  })
  
  # Set factor levels for ordering
  chord_data$network1 <- factor(chord_data$network1, levels = network_order)
  chord_data$network2 <- factor(chord_data$network2, levels = network_order)
  
  # Clear any previous plots
  circos.clear()
  
  # Set parameters
  circos.par(
    start.degree = 90, 
    gap.degree = 4
  )
  
  # Create chord diagram - use small constant value for thin chords
  chord_data_for_plot <- chord_data
  chord_data_for_plot$const_val <- 0.001  # Very small constant for thin chords
  
  chordDiagram(
    chord_data_for_plot[, c("network1", "network2", "const_val")],
    order = network_order,
    col = edge_colors,
    grid.col = network_colors,
    directional = 0,
    annotationTrack = "grid",
    preAllocateTracks = list(track.height = 0.1)
  )
  
  # Add network labels with full names
  circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    # Map abbreviation to full name
    full_name <- network_name_map[sector.name]
    if(is.na(full_name)) full_name <- sector.name
    
    circos.text(mean(xlim), ylim[1], full_name,
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),
                col = "black", font = 2, cex = 1.2)
  }, bg.border = NA)
  
  # Add title
  if (!is.null(plot_title)) {
    title(main = plot_title, cex.main = 1.3, line = 1)
  }
  
  circos.clear()
  
  return(data_clean)  # Return the processed data for reference
}

# Function to create chord diagrams for multiple contrasts
create_multiple_dcc_chords <- function(combined_detailed_table, contrasts_to_plot = NULL, 
                                     save_plots = FALSE, output_dir = NULL) {
  
  # Get available contrasts if not specified
  if (is.null(contrasts_to_plot)) {
    contrasts_to_plot <- combined_detailed_table %>%
      filter(variable == "DCC") %>%
      pull(contrast) %>%
      unique()
  }
  
  # Set up output directory if saving
  if (save_plots && !is.null(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  
  results <- list()
  
  # Generate chord diagram for each contrast
  for (contrast in contrasts_to_plot) {
    
    cat("\n========================================\n")
    cat("=== Processing:", contrast, "===\n")
    
    # Clean contrast name for title
    clean_contrast <- case_when(
      contrast == "PSI" ~ "Psilocybin",
      contrast == "LSD" ~ "LSD",
      contrast == "MES" ~ "Mescaline",
      contrast == "AMP" ~ "d-Amphetamine",
      contrast == "MDMA" ~ "MDMA",
      contrast == "LSD_VS_PSI" ~ "LSD vs Psilocybin",
      contrast == "LSD_VS_MES" ~ "LSD vs Mescaline",
      contrast == "MES_VS_PSI" ~ "Mescaline vs Psilocybin",
      contrast == "MDMA_VS_AMP" ~ "MDMA vs d-Amphetamine",
      contrast == "PSI_vs_AMP" ~ "Psilocybin vs d-Amphetamine",
      contrast == "LSD_vs_AMP" ~ "LSD vs d-Amphetamine",
      contrast == "MES_vs_AMP" ~ "Mescaline vs d-Amphetamine",
      contrast == "PSI_vs_MDA" ~ "Psilocybin vs MDMA",
      contrast == "LSD_vs_MDA" ~ "LSD vs MDMA",
      contrast == "MES_vs_MDA" ~ "Mescaline vs MDMA",
      TRUE ~ contrast
    )
    
    if (save_plots && !is.null(output_dir)) {
      # Create filename
      clean_filename <- gsub("[^A-Za-z0-9_]", "_", contrast)
      clean_filename <- gsub("_{2,}", "_", clean_filename)
      clean_filename <- gsub("_$", "", clean_filename)
      filepath <- file.path(output_dir, paste0("DCC_chord_", clean_filename, ".png"))
      
      # Start PNG device
      png(filepath, width = 2000, height = 2000, res = 300)
      par(mar = c(1, 1, 3, 1))
    }
    
    # Create the chord diagram
    result_data <- create_dcc_chord_diagram(
      combined_detailed_table, 
      contrast,
      plot_title = clean_contrast
    )
    
    if (save_plots && !is.null(output_dir)) {
      dev.off()
      cat("\n✓ Saved:", filepath, "\n")
    }
    
    results[[contrast]] <- result_data
  }
  
  return(results)
}

# Convenience function to create chord diagrams by contrast type
create_dcc_chords_by_type <- function(combined_detailed_table, contrast_type = "all", 
                                    save_plots = FALSE, output_dir = NULL) {
  
  # Get all available contrasts
  all_contrasts <- combined_detailed_table %>%
    filter(variable == "DCC") %>%
    pull(contrast) %>%
    unique()
  
  # Filter contrasts by type
  if (contrast_type == "individual") {
    contrasts <- c("PSI", "LSD", "MES", "AMP", "MDMA")
  } else if (contrast_type == "within") {
    contrasts <- c("LSD_VS_PSI", "LSD_VS_MES", "MES_VS_PSI", "MDMA_VS_AMP")
  } else if (contrast_type == "between") {
    contrasts <- c("PSI_vs_AMP", "LSD_vs_AMP", "MES_vs_AMP", 
                   "PSI_vs_MDA", "LSD_vs_MDA", "MES_vs_MDA")
  } else {
    contrasts <- all_contrasts
  }
  
  # Filter to only existing contrasts
  contrasts <- contrasts[contrasts %in% all_contrasts]
  
  return(create_multiple_dcc_chords(combined_detailed_table, contrasts, save_plots, output_dir))
}

# ---- Usage ----

# # Create chord diagrams for individual drug effects
# individual_chords <- create_dcc_chords_by_type(combined_detailed_table, "individual", 
#                                               save_plots = TRUE, 
#                                               output_dir = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/")
# 
# # Create chord diagrams for within-class comparisons
# within_chords <- create_dcc_chords_by_type(combined_detailed_table, "within",
#                                           save_plots = TRUE,
#                                           output_dir = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/")
# 
# # Create chord diagrams for between-class comparisons
# between_chords <- create_dcc_chords_by_type(combined_detailed_table, "between",
#                                            save_plots = TRUE,
#                                            output_dir = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/")
# 
# # Create all chord diagrams
# all_chords <- create_multiple_dcc_chords(combined_detailed_table,
#                                         save_plots = TRUE,
#                                         output_dir = "/Volumes/users/kristianlarsen/Desktop/projects/Entropsy/Figures/R_outputs/")
```
